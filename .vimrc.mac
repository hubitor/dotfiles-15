" Startup {{{======================

" Note: Skip initialization for vim-tiny or vim-small.
if !1 | finish | endif

" release autogroup in MyVimrc {{{
augroup MyVimrc
    autocmd!
augroup END
" https://github.com/rhysd/dotfiles/blob/master/vimrc
command! -nargs=* Autocmd autocmd MyVimrc <args>
command! -nargs=* AutocmdFT autocmd MyVimrc FileType <args>
function! s:hl_my_autocmd()
    highlight def link myVimAutocmd vimAutoCmd
    syntax match vimAutoCmd /\<\(Autocmd\|AutocmdFT\)\>/
endfunction
Autocmd BufWinEnter,ColorScheme *vimrc call s:hl_my_autocmd()
"}}}

" Echo startup time on start {{{
if has('vim_starting') && has('reltime')
    " Shell: vim --startuptime filename -q; vim filename
    " vim --cmd 'profile start profile.txt' --cmd 'profile file $HOME/.vimrc' +q && vim profile.txt
    let s:startuptime = reltime()
    Autocmd VimEnter * let s:startuptime = reltime(s:startuptime) | redraw
    \ | echomsg 'startuptime: ' . reltimestr(s:startuptime)
endif
"}}}
"}}}

" NeoBundle {{{====================
 " Note: Skip initialization for vim-tiny or vim-small.
 if 0 | endif

 if has('vim_starting')
   if &compatible
     set nocompatible               " Be iMproved
   endif

   " Required:
   set runtimepath+=~/.vim/bundle/neobundle.vim/
 endif

 " Required:
 call neobundle#begin(expand('~/.vim/bundle/'))
" NeoBundle Function {{{
    NeoBundleFetch 'Shougo/neobundle.vim'

    " Synthesis {{{
    " Unite {{{
    NeoBundleLazy 'Shougo/unite.vim'

    NeoBundle 'Shougo/neomru.vim'
    NeoBundleLazy 'Shougo/unite-help'
    NeoBundleLazy 'ujihisa/unite-colorscheme'
    NeoBundleLazy 'Shougo/unite-outline'
    NeoBundleLazy 'osyo-manga/unite-fold'
    NeoBundleLazy 'kmnk/vim-unite-giti'
    NeoBundleLazy 'thinca/vim-unite-history'
    NeoBundleLazy 'osyo-manga/unite-quickfix'
    NeoBundleLazy 'moznion/unite-git-conflict.vim'
    NeoBundleLazy 'Shougo/unite-session'
    NeoBundleLazy 'osyo-manga/unite-vimpatches'
    NeoBundleLazy 'tsukkee/unite-tag'
    NeoBundleLazy 'haya14busa/unite-ghq'
    NeoBundleLazy 'rhysd/unite-zsh-cdr.vim'
    NeoBundleLazy 'haya14busa/unite-reading-vimrc'
    NeoBundleLazy 'osyo-manga/unite-vimmer'
    NeoBundleLazy 'haya14busa/unite-historia'
    " action
    NeoBundleLazy 'osyo-manga/ref-lynx'
    NeoBundleLazy 'haya14busa/unite-action-vimfiler_lcd'
    NeoBundle 'lambdalisue/vim-gista'
    
    " neobundle.vim (Lazy)
    NeoBundleLazy 'lambdalisue/vim-gista', {
    \ 'autoload': {
    \    'commands': ['Gista'],
    \    'mappings': '<Plug>(gista-',
    \    'unite_sources': 'gista',
    \}}

    "}}}
    NeoBundleLazy 'Shougo/vimfiler.vim'
    NeoBundleLazy 'Shougo/vimshell.vim'

    "}}}

    " Writing {{{
    " Shougo/neocomplete {{{
    if has('lua') && v:version >= 703
        NeoBundleLazy 'Shougo/neocomplete.vim'
    else
        NeoBundleLazy 'Shougo/neocomplcache.vim'
    endif
    "}}}
    NeoBundleLazy 'Shougo/neosnippet.vim'
    NeoBundle 'haya14busa/haya14busa-snippets'
    NeoBundleLazy 'mattn/emmet-vim'
    NeoBundleLazy 'deris/vim-rengbang'
    NeoBundle 'deris/vim-visualinc'
    NeoBundleLazy 'h1mesuke/vim-alignta'
    NeoBundleLazy 'tyru/caw.vim'
    NeoBundleLazy 'ujihisa/neco-look'
    NeoBundleLazy 'rhysd/vim-grammarous'
    "}}}

    " Development {{{
    NeoBundleLazy 'thinca/vim-quickrun'

    NeoBundleLazy "osyo-manga/vim-watchdogs"

    NeoBundleLazy 'koron/codic-vim'
    NeoBundleLazy 'rhysd/unite-codic.vim'
    "}}}

    " Library {{{
    NeoBundle 'Shougo/vimproc'
    NeoBundle 'mattn/webapi-vim'
    NeoBundleLazy 'vim-jp/vital.vim'
    NeoBundleLazy 'osyo-manga/unite-vital-module'
    NeoBundle 'osyo-manga/vital-over'
    NeoBundle 'osyo-manga/vital-reunions'
    NeoBundle 'osyo-manga/vital-coaster'
    "}}}

    " Document {{{
    NeoBundleLazy 'thinca/vim-ref'
    NeoBundle 'mojako/ref-sources.vim'
    NeoBundle 'tokuhirom/jsref'
    NeoBundle 'mustardamus/jqapi'
    NeoBundle 'soh335/vim-ref-jquery'

    "}}}

    " Extend Basic Vim Commands {{{
    " Matching
    NeoBundle 'matchit.zip'
    " Yank
    NeoBundleLazy 'LeafCage/yankround.vim'
    "NeoBundle 't9md/yankround.vim'

    " Undo
    NeoBundleLazy 'sjl/gundo.vim'
    " Visual mode
    NeoBundleLazy 'kana/vim-niceblock'
    " Search
    NeoBundleLazy 'thinca/vim-visualstar'
    "NeoBundleLazy 'osyo-manga/vim-anzu'
    NeoBundleLazy 'osyo-manga/vim-over'

    NeoBundle 'vim-jp/autofmt'

    "}}}

    " Motion {{{
    NeoBundleLazy 'Lokaltog/vim-easymotion'
    NeoBundleLazy 'haya14busa/vim-easyoperator-line'
    NeoBundleLazy 'haya14busa/vim-easyoperator-phrase'
    NeoBundleLazy 'haya14busa/vim-lazy-lines'
    NeoBundleLazy 'rhysd/clever-f.vim'
    NeoBundleLazy 'rhysd/accelerated-jk'
    NeoBundleLazy 'saihoooooooo/glowshi-ft.vim'
    NeoBundleLazy 'haya14busa/incsearch.vim'
    "}}}

    " Text Object {{{
    NeoBundleLazy 'kana/vim-textobj-user'
    NeoBundleLazy 'kana/vim-textobj-entire'           " ae, ie
    NeoBundleLazy 'kana/vim-textobj-fold'             " az, iz
    NeoBundleLazy 'kana/vim-textobj-indent'           " ai, ii
    NeoBundleLazy 'kana/vim-textobj-line'             " al, il
    NeoBundleLazy 'kana/vim-textobj-syntax'           " ay, iy
    NeoBundleLazy 'kana/vim-textobj-django-template'  " adb, idb
    NeoBundleLazy 'thinca/vim-textobj-between'        " af{char}, if{char}
    NeoBundleLazy 'mattn/vim-textobj-url'             " au, iu
    NeoBundleLazy 'osyo-manga/vim-textobj-multiblock' " ab, ib
    NeoBundleLazy 'lucapette/vim-textobj-underscore'  " a_, i_
    NeoBundleLazy 'haya14busa/vim-textobj-number'     " an, in
    " NeoBundleLazy 'h1mesuke/textobj-wiw'              " a,w a,e

    NeoBundle 'wellle/targets.vim'
    " NeoBundle 'gcmt/wildfire.vim'
    NeoBundle 'tpope/vim-surround'
    NeoBundle 'tpope/vim-repeat'

    " Operator
    NeoBundleLazy 'kana/vim-operator-user'
    NeoBundleLazy 'kana/vim-operator-replace'
    "NeoBundle 'rhysd/vim-operator-surround'
    NeoBundleLazy 'kana/vim-operator-replace', {
                \ 'autoload' : {
                \     'mappings' : '<Plug>(operator-replace)'
                \     }
                \ }

    NeoBundleLazy 'rhysd/vim-operator-trailingspace-killer', {
                \ 'autoload' : {
                \     'mappings' : '<Plug>(operator-trailingspace-killer)'
                \     }
                \ }

    NeoBundleLazy 'rhysd/vim-operator-filled-with-blank', {
                \ 'autoload' : {
                \     'mappings' : '<Plug>(operator-filled-with-blank)'
                \     }
                \ }

    NeoBundleLazy 'rhysd/vim-operator-evalruby', {
                \ 'autoload' : {
                \     'mappings' : '<Plug>(operator-evalruby)'
                \     }
                \ }

    NeoBundleLazy 'rhysd/vim-operator-surround', {
                \ 'depends' : 'tpope/vim-repeat',
                \ 'autoload' : {
                \       'mappings' : '<Plug>(operator-surround-'
                \   }
                \ }

    NeoBundleLazy 'deris/vim-operator-insert', {
                \ 'autoload' : {
                \   'mappings' : [
                \       '<Plug>(operator-insert-i)',
                \       '<Plug>(operator-insert-a)',
                \   ],
                \   },
                \ }

    "}}}

    " Git {{{
    NeoBundle 'tpope/vim-fugitive'
    NeoBundleLazy 'cohama/agit.vim'
    NeoBundle 'mhinz/vim-signify'

    NeoBundleLazy 'thinca/vim-openbuf'
    NeoBundleLazy 'Shougo/vim-vcs', {
        \ 'depends' : 'thinca/vim-openbuf',
        \ 'autoload' : {'commands' : 'Vcs'},
        \ }

    NeoBundle 'rhysd/committia.vim'
    "}}}

    " UI {{{
    NeoBundle 'itchyny/lightline.vim'
    NeoBundle 'Yggdroot/indentLine'
    NeoBundleLazy 'osyo-manga/vim-brightest'
    NeoBundleLazy 't9md/vim-quickhl'
    NeoBundleLazy 'mattn/disableitalic-vim'
    " TODO
    NeoBundleLazy 'osyo-manga/vim-automatic'
    ", {
    "    \ 'depends' : [ 'osyo-manga/vim-gift', 'osyo-manga/vim-reunions' ] }
    " }}}

    " Utility {{{
    " NeoBundle 'kana/vim-submode'
    NeoBundle 'thinca/vim-submode', {
        \ 'rev' : 'my-master',
        \ 'name' : 'vim-submode',
        \ }
    NeoBundleLazy 'tyru/open-browser.vim'
    NeoBundleLazy 'tyru/open-browser-github.vim'
    NeoBundleLazy 'thinca/vim-qfreplace'
    NeoBundleLazy 'haya14busa/endtagcomment.vim'
    "}}}

    " Application {{{
    NeoBundleLazy 'itchyny/calendar.vim'
    NeoBundleLazy 'itchyny/screensaver.vim'
    "}}}

    " Memo {{{
    "NeoBundleLazy 'mattn/gist-vim'
    NeoBundleLazy 'Shougo/junkfile.vim'
    "}}}

    " Filetype {{{
    "NeoBundleLazy 'osyo-manga/vim-precious'
    "let g:markdown_fenced_languages = [
    "\  'coffee',
    "\  'css',
    "\  'erb=eruby',
    "\  'javascript',
    "\  'js=javascript',
    "\  'json=javascript',
    "\  'ruby',
    "\  'sass',
    "\  'xml',
    "\  'python',
    "\  'vim',
    "\]
    NeoBundle 'pangloss/vim-javascript'
    NeoBundle 'wavded/vim-stylus'
    NeoBundle 'hail2u/vim-css3-syntax'
    NeoBundle 'kchmck/vim-coffee-script'
    NeoBundle 'othree/html5.vim'
    NeoBundle 'plasticboy/vim-markdown'
    NeoBundleLazy 'kannokanno/previm'
    NeoBundle 'groenewege/vim-less'

    " Python {{{
    "NeoBundleLazy 'davidhalter/jedi-vim'
    NeoBundleLazy 'heavenshell/vim-pydocstring'
    NeoBundleLazy 'tell-k/vim-autopep8'
    NeoBundleLazy 'hynek/vim-python-pep8-indent'
    NeoBundleLazy 'mkomitee/vim-gf-python'

    "}}}

    " JavaScript {{{
    "NeoBundleLazy 'marijnh/tern_for_vim'
    NeoBundleLazy 'maksimr/vim-jsbeautify'
    "}}}



    " Scala {{{
    NeoBundleLazy 'derekwyatt/vim-scala'
    NeoBundleLazy 'derekwyatt/vim-sbt'
    NeoBundleLazy 'mdreves/vim-scaladoc'
    NeoBundleLazy 'gre/play2vim'
    "}}}
    " Scheme {{{
    NeoBundleLazy 'aharisu/vim_goshrepl'
    NeoBundleLazy 'kien/rainbow_parentheses.vim'
    " }}}
    "}}}

    " Fold {{{
    "NeoBundle 'LeafCage/foldCC'
    NeoBundleLazy 'tmhedberg/SimpylFold' "for Python
    NeoBundleLazy 'vim-scripts/CSS-one-line--multi-line-folding'
    "}}}

    " Japanese {{{
    NeoBundle 'vim-jp/vimdoc-ja'
    " NeoBundle 'tyru/skk.vim'
    "}}}

    " ColorScheme {{{
    NeoBundle 'tomasr/molokai'
    NeoBundle 'sickill/vim-monokai'
    NeoBundle 'vim-scripts/Wombat'
    NeoBundle 'altercation/vim-colors-solarized'
    NeoBundle 'nanotech/jellybeans.vim'
    NeoBundle 'w0ng/vim-hybrid'
    NeoBundle 'vim-scripts/twilight'
    NeoBundle 'jonathanfilip/vim-lucius'
    NeoBundle 'jpo/vim-railscasts-theme'
    NeoBundle 'vim-scripts/rdark'
    NeoBundle 'djjcast/mirodark'
    NeoBundle 'sjl/badwolf'
    NeoBundle 'cocopon/iceberg.vim'
    NeoBundle 'reedes/vim-colors-pencil'
    "}}}

    " Vim script {{{
    NeoBundleLazy 'mattn/learn-vimscript'
    NeoBundleLazy 'thinca/vim-prettyprint'
    NeoBundleLazy 'tyru/capture.vim'
    NeoBundleLazy 'kana/vim-vspec'
    NeoBundleLazy 'thinca/vim-themis'
    NeoBundleLazy 'thinca/vim-editvar'
    NeoBundleLazy 'tyru/restart.vim'
    NeoBundleLazy 'thinca/vim-ft-help_fold', {
        \ 'filetypes' : 'help'
        \ }
    NeoBundleLazy 'syngan/vim-vimlint', {
        \ 'depends' : 'ynkdir/vim-vimlparser'}
    NeoBundle 'thinca/vim-localrc'
    "}}}

    " Others {{{
    NeoBundleLazy 'basyura/TweetVim'
    NeoBundleLazy 'basyura/twibill.vim'
    NeoBundleLazy 'basyura/J6uil.vim'
    NeoBundleLazy 'dogrover/vim-pentadactyl'
    NeoBundleLazy 'supermomonga/thingspast.vim'
    NeoBundleLazy 'rbtnn/puyo.vim'
    NeoBundleLazy 'thinca/vim-scouter'

    NeoBundleLazy 'thinca/vim-threes'
    " NeoBundle 'tpope/vim-rake'
    NeoBundleLazy 'mattn/flappyvird-vim'
    NeoBundleLazy 'mattn/yamada2-vim'
    "}}}
    
    " Plugins {{{
    "NeoBundle 'osyo-manga/vim-brightest'
    "NeoBundle 'eagletmt/ghci-vim'
    "NeoBundle 'eagletmt/ghcmod-vim'
    "NeoBundle 'cohama/vim-exchange'
    "NeoBundle 'cohama/vim-insert-linenr'
    "NeoBundle 'maxbrunsfeld/vim-yankstack'
    "NeoBundle 'visualmark.vim'
    "NeoBundle 'airblade/vim-gitgutter'
    "NeoBundle 'ShowMarks'
    "NeoBundle 'kien/ctrlp.vim'
    "NeoBundle 'YankRing.vim'
    " ======================
    NeoBundle 'kana/vim-fakeclip'
    NeoBundle 'jacquesbh/vim-showmarks'
    NeoBundle 'Lokaltog/vim-powerline'
    NeoBundle 'sgur/vim-lazygutter'
    NeoBundle 'tacroe/unite-mark'
    NeoBundle 'deris/columnjump'
    NeoBundle 't9md/vim-textmanip'
    NeoBundle 't9md/vim-choosewin'
    NeoBundle 'deris/vim-cmdline-switch'
    NeoBundle 'taglist.vim'
    NeoBundle 'yonchu/accelerated-smooth-scroll'
    NeoBundle 'syui/airsave.vim'
    NeoBundle 'syui/j6uil_notify'
    NeoBundle 'cohama/lexima.vim'
    NeoBundle 'deris/vim-shot-f'
    NeoBundle 'tmhedberg/matchit'
    NeoBundle 'elzr/vim-json'
    NeoBundle 'terryma/vim-multiple-cursors'
    NeoBundle 'koron/codic-vim'
    NeoBundle 'slim-template/vim-slim'
    NeoBundle 'gist:rhysd/4201877', {
    \   'name': 'tweetvim_update',
    \   'script_type': 'plugin'
    \}
NeoBundle 'lambdalisue/vim-gista'

" neobundle.vim (Lazy)
NeoBundleLazy 'lambdalisue/vim-gista', {
    \ 'autoload': {
    \    'commands': ['Gista'],
    \    'mappings': '<Plug>(gista-',
    \    'unite_sources': 'gista',
    \}}
"let g:gista#github_user = 'User Name'

 " My Bundles here:
 " Refer to |:NeoBundle-examples|.
 " Note: You don't set neobundle setting in .gvimrc!
 call neobundle#end()
 " Required:
 filetype plugin indent on

 " If there are uninstalled bundles found on startup,
 " this will conveniently prompt you to install them.
" NeoBundleCheck

" END NeoBundle}}}

" Vim Setup  {{{====================

" Basic Options {{{
if exists('&ambiwidth')
" For Ubuntu: gnome-terminal, terminator, guake
"   /bin/sh -c "VTE_CJK_WIDTH=1 terminator -m"
"   /bin/sh -c "VTE_CJK_WIDTH=1 gnome-terminal --disable-factory"
"   /bin/sh -c "VTE_CJK_WIDTH=1 guake"
"   https://gist.github.com/sgk/5991138
    set ambiwidth=double "Use twice the width of ASCII characters for Multibyte
endif
set autoread "Automatically read file again which has been changed outside of Vim
set backspace=indent,eol,start "Working of <BS>,<Del>,CTRL-W,CTRL-U
if has('unnamedplus')
    set clipboard& clipboard=unnamedplus "uses the clipboard register '+'
else
    set clipboard& clipboard+=unnamed,autoselect
endif
set cmdheight=1 "Number of screen lines to use for the command-line
set cmdwinheight=5 "Number of screen lines to use for the command-line window
set display=lastline "Display as much as possible of the last line
set formatoptions-=r,o " Turn off Automatically comment out when line break
set grepprg=internal "Program to use for the :grep command
set helpheight=12 " Minimal initial height of the help window
set helplang& helplang=en,ja " If true Vim master, use English help file
set hidden "Display another buffer when current buffer isn't saved.
set history=1024 "Amount of Command history
set infercase "Ignore case on insert completion.
set keywordprg=:help " Open Vim internal help by K command
set laststatus=2 "Always display statusline
set matchpairs& matchpairs+=<:> "Characters that form pairs
set matchtime=3 "Tenths of a second to show the matching paren
set modeline "Set Vim local buffer option to specific file
set noerrorbells "Don't ring the bell for error messages
set novisualbell "Don't use visual bell instead of beeping
set nrformats-=octal "Bases Vim will consider for numbers(Ctrl-a,Ctrl-x)
set number "Print the line number in front of each line
set ruler "Show the line and column number of the cursor position
set shortmess& shortmess+=I "Don't give the message when starting Vim :intro
set showcmd "Show (partial) command in the last line of the screen
set showmatch "Briefly jump to the matching one
set spelllang=en,cjk "Spell checking language
set textwidth=0 "Maximum width of text that is being inserted
set viewoptions=cursor,folds "Changes the effect of the :mkview command
"set viminfo+=! "Store information when you exit Vim for later
set viminfo='50,\"1000,:0,n~/.vim/viminfo
set virtualedit=block "Cursor can be positioned virtually when Visual-block mode
set whichwrap=b,s,h,l,[,],<,> "Allow specified keys to move to the previous/next line
set wrap "Lines longer than the width of the window will wrap
set wrapscan "Searches wrap around the end of the file

language C "Set locale

" Encoding {{{
set encoding=utf-8 "Sets the character encoding used inside Vim
set termencoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8,cp932,euc-jp "A list of character encodings
set fileformats=unix,dos,mac "This gives the end-of-line (<EOL>) formats
" }}}

" Tab Basic Settings {{{
set autoindent "Copy indent from current line when starting a new line
set expandtab "Use the appropriate number of spaces to insert a <Tab>
set shiftround "Round indent to multiple of 'shiftwidth'
set shiftwidth=4 "Number of spaces to use for each step of (auto)indent
set softtabstop=4 "Number of spaces that a <Tab> counts for while editing operations
set tabstop=4 "Number of spaces that a <Tab> in the file counts for
"}}}

" Search Basic Settings {{{
set incsearch "Incremental searching
set ignorecase "Ignore case in search patterns
set smartcase "Override the ignorecase option if the pattern contains upper case
" set hlsearch | nohlsearch "Highlight search patterns, support reloading
"}}}

" Backup Settings {{{
"Don't create backup
set nobackup "Don't make a backup before overwriting a file
set nowritebackup "Don't make a backup before overwriting a file
set backupdir-=. "List of directories for the backup file
"}}}

" Swap Settings {{{
set swapfile "Use a swapfile for the buffer
if ! isdirectory($HOME.'/.vim/swap')
    call mkdir($HOME.'/.vim/swap', 'p')
endif
set directory=~/.vim/swap
"}}}

" Undo Basic {{{
if has('persistent_undo')
    if ! isdirectory($HOME.'/.vim/undo')
        call mkdir($HOME.'/.vim/undo', 'p')
    endif
    set undofile "Automatically saves undo history
    set undoreload=1000 "Save the whole buffer for undo when reloading it
    set undodir=~/.vim/undo
    set undofile
endif
"}}}

" Wildmenu {{{
set wildmenu " Command line autocompletion
set wildmode=list:longest,full "Shows all the options

set wildignore& " A file that matches with one of these patterns is ignored
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.bak,*.?~,*.??~,*.???~,*.~      " Backup files
set wildignore+=*.luac                           " Lua byte code
set wildignore+=*.jar                            " Java archives
set wildignore+=*.pyc                            " Python byte code
set wildignore+=*.stats                          " Pylint stats

" }}}

" Fold Basic Settings "{{{
set foldenable "Enable fold
set foldlevel=100 "Folds with a higher level will be closed
"}}}

" Colorscheme {{{
" Check color
" :so $VIMRUNTIME/syntax/colortest.vim
set t_Co=256
if has('vim_starting')
    syntax enable
    set background=dark
    set t_Co=256
    if &t_Co < 256
        "colorscheme molokai
        colorscheme default
    else
        try
            colorscheme molokai
        catch
            colorscheme desert
        endtry
    endif
endif
"}}}

"colorscheme molokai
"}}}


" Open & AutoReload .vimrc {{{
command! EVimrc e $MYVIMRC
command! ETabVimrc tabnew $MYVIMRC
command! SoVimrc source $MYVIMRC
Autocmd BufWritePost *vimrc NeoBundleClearCache | source $MYVIMRC
Autocmd BufWritePost *gvimrc if has('gui_running') source $MYGVIMRC
"}}}

" Close Vim help by q {{{
AutocmdFT help nnoremap <buffer> q <C-w>c
AutocmdFT help nnoremap <buffer> ;q q
AutocmdFT help nnoremap <buffer> Q q
"}}}

" Useful Keymaps{{{

" Escape Keymaps {{{
"inoremap <silent> jk <ESC>
"inoremap <silent> jf <ESC>
inoremap <silent> jj <ESC>
"}}}

" Breakline with Enter {{{
" nnoremap <CR> o<ESC>
"}}}

" For Undo Revision, Break Undo Sequence "{{{
inoremap <CR> <C-g>u<CR>

inoremap <C-h> <C-g>u<C-h>
inoremap <BS> <C-g>u<BS>
inoremap <Del> <C-g>u<Del>
inoremap <C-d> <C-g>u<Del>
inoremap <C-w> <C-g>u<C-w>
inoremap <C-u> <C-g>u<C-u>

"}}}

" Motion {{{

" Normal Mode {{{
nnoremap j gj
vnoremap j gj
nnoremap gj j
vnoremap gj j

nnoremap k gk
vnoremap k gk
nnoremap gk k
vnoremap gk k

nnoremap - $
"}}}

" Insert & Comandline Mode "{{{
inoremap <C-b> <Left>
inoremap <C-f> <Right>
inoremap <C-a> <Home>
inoremap <C-e> <End>

cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>

" Word Motion in Insert Mode
inoremap <M-w> <S-Right>
inoremap <M-b> <S-Left>
"}}}

" Scroll {{{
nnoremap <C-e> <C-e>j
nnoremap <C-y> <C-y>k
nnoremap <C-f> <C-f>zz
nnoremap <C-b> <C-b>zz

"nmap <Leader>v <C-v>
"nnoremap <space>j <C-f>zz
"nnoremap <space>k <C-b>zz
"vnoremap <space>j <C-f>zz
"vnoremap <space>k <C-b>zz
"}}}

"}}}

" Paste in insert and Command-line mode"{{{
inoremap <C-y><C-y> <C-r>+
cnoremap <C-y><C-y> <C-r>+
"}}}

" Vertical Paste"{{{
vnoremap <C-p> I<C-r>+<ESC><ESC>
"}}}


" Command line History {{{
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
"}}}

" Save as root"{{{
cnoremap w!! w !sudo tee > /dev/null %
"}}}


nnoremap Y y$
"}}}

" Yank with keeping cursor position in visual mode {{{
function! s:keepcursor_visual_wrapper(command)
    exec "normal! gv" . a:command
    exec "normal! gv\<ESC>"
endfunction
xnoremap <silent> y :<C-u>call <SID>keepcursor_visual_wrapper('y')<CR>
xnoremap <silent> Y :<C-u>call <SID>keepcursor_visual_wrapper('Y')<CR>
" Below mappings doesn't support dot repeat
" xnoremap <silent> > :<C-u>call <SID>keepcursor_visual_wrapper('>')<CR>
" xnoremap <silent> < :<C-u>call <SID>keepcursor_visual_wrapper('<')<CR>
"}}}

" Spelling Keymaps {{{
" Toggle spell checking
nnoremap <Leader>sp :<C-u>set spell! spell?<CR>
" }}}

" Get info"{{{
" get the total of lines, words, chars and bytes (and for the current position)
nnoremap <Leader>gi g<C-G>
"}}}

" Relative Number "{{{
nnoremap <Leader><Leader>r :<C-u>set relativenumber!<CR>
"}}}

" Repeat on every line {{{
" repeat last command for each line of a visual selection
vnoremap . :normal .<CR>
" replay @q macro for each line of a visual selection
vnoremap @q :normal @q<CR>
"}}}

" Search {{{
" always 'very magic'
" nnoremap / /\v
" search within visual block
" vnoremap / <esc>/\v%V
" clear status
nnoremap <silent><Esc><Esc>
      \ :<C-u>nohlsearch<CR>
" nnoremap <silent><Esc><Esc>
"       \ :<C-u>set hlsearch! hlsearch?<CR>

" Automatically escape '/'
" cnoremap <expr>/ getcmdtype() == '/' ? '\/' : '/'

nnoremap & :&&<CR>
xnoremap & :&&<CR>
"}}}

" select last inserted text
nnoremap gV `[v`]

" Select pasted text
nnoremap <expr>gp '`['.strpart(getregtype(),0,1).'`]'

" Don't use register by x
nnoremap x "_x

" Keymap candidate
" n
" ---
" U
" S
" X
"}}}

" set nopaste when Insertleave"{{{
Autocmd InsertLeave * set nopaste
"}}}

" Show invisibles {{{

" Shortcut to rapidly toggle `set list`
nnoremap <silent> <Leader>l :<C-u>set list! list?<CR>

" Use the same symbols as TextMate for tabstops and EOLs
set listchars=tab:▸\ ,
set list

" Highlight End-of-Line & Zenkaku Whitespace {{{
function! s:hl_trailing_spaces() "{{{
    " Test   
    highlight! link TrailingSpaces Error
    syntax match TrailingSpaces containedin=ALL /\s\+$/
endfunction "}}}
function! s:hl_zenkaku() "{{{
    highlight! link ZenkakuSpace Error
    syntax match ZenkakuSpace containedin=ALL /　/
endfunction "}}}

Autocmd BufWinEnter,ColorScheme * call s:hl_trailing_spaces()
Autocmd BufWinEnter,ColorScheme * call s:hl_zenkaku()

function! s:remove_trailing_white_spaces()
    let pos = winsaveview()
    silent! execute '%s/\s\+$//g'
    call winrestview(pos)
endfunction
command! RemoveTrailingWhiteSpaces call <SID>remove_trailing_white_spaces()
command! -range=% TrimSpace  <line1>,<line2>s!\s*$!!g | nohlsearch
" remove trail ^M
command! -range=% RemoveTrailM  <line1>,<line2>s!\r$!!g | nohlsearch
"}}}

"}}}

" Resize splits when the window is resized {{{
Autocmd VimResized * :wincmd =
"}}}

" Restore last cursor position when open a file {{{
" Autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
"}}}

" {{{
"nmap <Space> [fold]
"vmap <Space> [fold]
"
"noremap [fold]j zj
"noremap [fold]k zk
"noremap [fold]n ]z
"noremap [fold]p [z
"noremap <silent>[fold]h :<C-u>call <SID>smart_foldcloser()<CR>
"noremap [fold]l zo
"noremap [fold]L zO
"noremap [fold]a za
"noremap [fold]m zM
"noremap [fold]i zMzvzz
"noremap [fold]r zR
"noremap [fold]f zf
"noremap [fold]d zd
"
"nnoremap <expr>l  foldclosed('.') != -1 ? 'zo' : 'l'
"
"nnoremap  [fold][     :<C-u>call <SID>put_foldmarker(0)<CR>
"nnoremap  [fold]]     :<C-u>call <SID>put_foldmarker(1)<CR>
"}}}

" smart_foldcloser {{{
function! s:smart_foldcloser()
    if foldlevel('.') == 0
        norm! zM
        return
    endif

    let foldc_lnum = foldclosed('.')
    norm! zc
    if foldc_lnum == -1
        return
    endif
    if foldclosed('.') != foldc_lnum
        return
    endif
    norm! zM
endfunction
"}}}

" put foldmarker {{{
function! s:put_foldmarker(foldclose_p)
    let crrstr = getline('.')
    let padding = crrstr=='' ? '' : crrstr=~'\s$' ? '' : ' '
    let [cms_start, cms_end] = ['', '']
    let outside_a_comment_p = synIDattr(synID(line('.'), col('$')-1, 1), 'name') !~? 'comment'
    if outside_a_comment_p
        let cms_start = matchstr(&cms,'\V\s\*\zs\.\+\ze%s')
        let cms_end = matchstr(&cms,'\V%s\zs\.\+')
    endif
    let fmr = split(&fmr, ',')[a:foldclose_p]. (v:count ? v:count : '')
    exe 'norm! A'. padding. cms_start. fmr. cms_end
endfunction
"}}}

"}}}

" Tab {{{

" Tab KeyMaps {{{
nnoremap t; t
nmap t <nop>
nnoremap tl gt
nnoremap th gT
nnoremap to :<C-u>edit<Space>
nnoremap tt :<C-u>tabnew<Space>
nnoremap <silent> td :<C-u>tabclose<CR>

nnoremap <silent> t] :<C-u>buffer<CR>
nnoremap <silent> tn :<C-u>bnext<CR>
nnoremap <silent> tp :<C-u>bprevious<CR>
nnoremap <silent> tD :<C-u>bdelete<CR>
nnoremap <silent> tL :<C-u>buffers<CR>
"}}}

" Tab jump {{{
for s:n in range(1, 9)
    execute 'nnoremap <silent> t'.s:n  ':<C-u>tabnext'.s:n.'<CR>'
endfor
unlet s:n
"}}}

" MoveToNewTab {{{
" http://www.sopht.jp/blog/index.php?/archives/445-vim.html
nnoremap <silent> tm :<C-u>call <SID>MoveToNewTab()<CR>
function! s:MoveToNewTab()
    tab split
    tabprevious

    if winnr('$') > 1
        close
    elseif bufnr('$') > 1
        buffer #
    endif

    tabnext
endfunction
"}}}

" Tab Help {{{
"nnoremap <Space>t :<C-u>tab help<Space>
"nnoremap <Space>v :<C-u>vertical belowright help<Space>
"}}}

" TabLine {{{
set tabline=%!MakeTabLine()

function! MakeTabLine()
    let s = ''

    for n in range(1, tabpagenr('$'))
        if n == tabpagenr()
            let s .= '%#TabLineSel#'
        else
            let s .= '%#TabLine#'
        endif

        let s .= '%' . n . 'T'

        let s .= ' %{MakeTabLabel(' . n . ')} '

        let s .= '%#TabLineFill#%T'
        let s .= '|'
    endfor

    let s .= '%#TabLineFill#%T'
    let s .= '%=%#TabLine#'
    let s .= '%{fnamemodify(getcwd(), ":~:h")}%<'
    return s
endfunction

function! MakeTabLabel(n)
    let bufnrs = tabpagebuflist(a:n)
    let bufnr = bufnrs[tabpagewinnr(a:n) - 1]

    let bufname = bufname(bufnr)
    if bufname == ''
        let bufname = '[No Name]'
    else
        let bufname = fnamemodify(bufname, ":t")
    endif

    let no = len(bufnrs)
    if no == 1
        let no = ''
    endif

    let mod = len(filter(bufnrs, 'getbufvar(v:val, "&modified")')) ? '+' : ''
    let sp = (no . mod) == '' ? '' : ' '

    let s = no . mod . sp . bufname
    return s
endfunction "}}}

"}}}

" Use command-line window {{{
"nnoremap : q:
"vnoremap : q:

Autocmd CmdwinEnter * call s:init_cmdwin()
function! s:init_cmdwin() "{{{
    silent! 1,$-20 delete _ | call cursor('$', 0)

    nnoremap <silent><buffer>q          :<C-u>quit<CR>
    nnoremap <silent><buffer><CR>       <CR>
    inoremap <silent><buffer><expr><CR> pumvisible() ? "\<C-y>\<CR>" : "\<CR>"
    nnoremap <silent><buffer><TAB>      :<C-u>quit<CR>

    nnoremap <silent><buffer><Space> <CR>q:
    nnoremap <silent><buffer>;;      <CR>q:
    inoremap <silent><buffer>;;      <CR>q:

    " Completion.
    inoremap <silent><buffer><expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    inoremap <silent><buffer><expr><C-p>  pumvisible() ? "\<C-p>" : "\<C-o>0\<UP>"
    inoremap <silent><buffer><expr><C-n>  pumvisible() ? "\<C-n>" : "\<C-o>0\<DOWN>"

    startinsert!
endfunction "}}}
"}}}

" Create Directory Automatically {{{
Autocmd BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)
function! s:auto_mkdir(dir, force)  " {{{
    if !isdirectory(a:dir) && (a:force ||
    \  input(printf('"%s" does not exist. Create? [y/N]', a:dir)) =~? '^y\%[es]$')
        call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
    endif
endfunction  " }}}
"}}}

" Git Setting {{{
" key mapping in vimdiff
function! s:config_in_diff_mode()
    if !&diff
        return
    endif
    " for git mergetool
    nnoremap <buffer> <Leader>1 :diffget LOCAL<CR>
    nnoremap <buffer> <Leader>2 :diffget BASE<CR>
    nnoremap <buffer> <Leader>3 :diffget REMOTE<CR>
    nnoremap <buffer> <Leader>u :<C-u>diffupdate<CR>
    nnoremap <buffer> u u:<C-u>diffupdate<CR>
    " same bindings for merging diffs as in normal mode
    xnoremap <buffer> dp :diffput<cr>
    xnoremap <buffer> do :diffget<cr>
endfunction

Autocmd FilterWritePre * call s:config_in_diff_mode()


" Update diff
Autocmd InsertLeave * if &l:diff | diffupdate | endif
" Spell check in git commit
AutocmdFT gitcommit setlocal nofoldenable spell
" Set textwidth
AutocmdFT gitcommit setlocal textwidth=0
" Enter Insert mode in git commit
Autocmd VimEnter COMMIT_EDITMSG if getline(1) == '' | execute 1 | startinsert | endif

" git blame {{{
function! s:git_blame(fname, ...)
    execute 'lcd' fnamemodify(a:fname, ':p:h')
    let range = (a:0==0 ? line('.') : a:1.','.a:2)
    let errfmt = &errorformat
    set errorformat=.*
    cgetexpr system('git blame -L '.range.' '.fnamemodify(a:fname, ':p'))
    let &errorformat = errfmt
    Unite quickfix -no-start-insert
endfunction
command! -nargs=0 GitBlameThisLine call <SID>git_blame(expand('%'))
command! -range GitBlameRange call <SID>git_blame(expand('%'), <line1>, <line2>)
nnoremap <silent><Leader>gb :<C-u>GitBlameThisLine<CR>
vnoremap <silent><Leader>gb :GitBlameRange<CR>
"}}}

"}}}

" Filetypes "{{{====================

" Stylus {{{
Autocmd BufRead,BufNewFile,BufReadPre *.styl setlocal filetype=sass
AutocmdFT sass     setlocal sw=2 sts=2 ts=2 et
" Autocmd BufWritePost,FileWritePost *.styl silent !stylus <afile> -u nib >/dev/null
"}}}

" CoffeeScript {{{
Autocmd BufRead,BufNewFile,BufReadPre *.coffee   setlocal filetype=coffee
AutocmdFT coffee     setlocal sw=2 sts=2 ts=2 et
Autocmd BufWritePost,FileWritePost *.coffee silent CoffeeMake! -cb | cwindow | redraw!
"}}}

" Sass {{{
function! Sass_convert()
    let scss = expand('%:p')
    let css  = substitute(scss, 'scss$', 'css', '')
    let cmd  = printf('sass --compass -i /usr/local/lib/ruby/gems/1.9.1/gems/compass-0.12.2/frameworks/compass/stylesheets/compass %s %s', scss, css)
    let res  = system(cmd)
    if res != ''
        echo res
    endif
endfunction

" Autocmd BufWritePost *.scss call Sass_convert()
"}}}

" Markdown {{{
Autocmd BufRead,BufNewFile *.md  set filetype=markdown
AutocmdFT markdown setlocal sw=2 sts=2 ts=2 et

AutocmdFT markdown nnoremap <buffer><silent><Leader>= :<C-u>call append('.', repeat('=', strdisplaywidth(getline('.'))))<CR>
AutocmdFT markdown nnoremap <buffer><silent><Leader>- :<C-u>call append('.', repeat('-', strdisplaywidth(getline('.'))))<CR>
"}}}

AutocmdFT html setlocal sw=2 sts=2 ts=2 et
AutocmdFT scss setlocal sw=2 sts=2 ts=2 et
AutocmdFT yaml setlocal sw=2 sts=2 ts=2 et

AutocmdFT c   setlocal foldmethod=syntax
AutocmdFT cpp setlocal foldmethod=syntax

AutocmdFT ruby setlocal sw=2 sts=2 ts=2 et

Autocmd BufRead,BufNewFile *.scala  set filetype=scala
Autocmd BufRead,BufNewFile *.sbt set filetype=sbt
AutocmdFT scala setlocal foldmethod=syntax
AutocmdFT scala setlocal sw=2 sts=2 ts=2 et

set tags+=.tags
Autocmd BufRead,BufNewFile *.scala setlocal tags+=~/tags/src/scala/.tags
Autocmd BufRead,BufNewFile *.scala setlocal tags+=~/tags/src/playframework/.tags
Autocmd BufRead,BufNewFile *.scala.html setlocal tags+=~/tags/src/playframework/.tags
Autocmd BufRead,BufNewFile *.scala setlocal tags+=~/tags/src/slick/.tags
"}}}

" end vim setup}}}

" Secret {{{=======================
if filereadable(expand('~/.secret_vimrc'))
    execute 'source' expand('~/.secret_vimrc')
endif
" }}}

" Plugin settings {{{==============

" " author/sample {{{
" if neobundle#tap('plugin-name')
"   " Config {{{
"   call neobundle#config({
"         \   'autoload' : {
"         \     'unite_sources' : [
"         \       'help',
"         \     ],
"         \   }
"         \ })
"   " }}}
"   function! neobundle#tapped.hooks.on_source(bundle) "{{{
"   endfunction "}}}
"   " Setting {{{
"   "}}}
"   call neobundle#untap()
" endif
" " }}}

" shougo/vimproc "{{{
if neobundle#tap('vimproc')
    call neobundle#config({
       \ 'build' : {
       \     'windows' : 'make -f make_mingw32.mak',
       \     'cygwin'  : 'make -f make_cygwin.mak',
       \     'mac'     : 'make -f make_mac.mak',
       \     'unix'    : 'make -f make_unix.mak',
       \    },
       \ })
    call neobundle#untap()
endif
"}}}

" Shougo/unite.vim"{{{
if neobundle#tap('unite.vim')
    " Config"{{{
    call neobundle#config({
        \   'depends': ['Shougo/vimproc'],
        \   'autoload' : {
        \     'commands' : [
        \       {
        \         'name' : 'Unite',
        \         'complete' : 'customlist,unite#complete_source'
        \       },
        \       'UniteWithCursorWord',
        \       'UniteWithInput'
        \     ]
        \   }
        \ }) "}}}

    function! neobundle#tapped.hooks.on_post_source(bundle)
        NeoBundleSource unite-action-vimfiler_lcd
    endfunction

    " Settings"{{{
    function! neobundle#tapped.hooks.on_source(bundle)
        " Disable
        let g:unite_source_history_yank_enable = 0

        let g:unite_kind_jump_list_after_jump_scroll=0
        let g:unite_enable_start_insert = 1
        let g:unite_source_rec_min_cache_files = 1000
        let g:unite_source_rec_max_cache_files = 5000
        let g:unite_source_file_mru_long_limit = 6000
        let g:unite_source_file_mru_limit = 500
        let g:unite_source_directory_mru_long_limit = 6000
        let g:unite_prompt = '❯ '
        let g:unite_winheight = 25
        " Open plugin directory by t
        call unite#custom#alias('directory', 'tabopen', 'tabvimfiler')

        " Fuzzy find
        call unite#filters#matcher_default#use(['matcher_fuzzy'])
        call unite#filters#sorter_default#use(['sorter_rank'])

        call unite#custom#default_action('directory', 'vimshell')
        call unite#custom#default_action('cdable', 'vimshell')

        call unite#custom#source(
                    \   'file_mru', 'matchers',
                    \   ['matcher_project_files', 'matcher_fuzzy'])

        " Ignore pattens
        call unite#custom#source(
            \ 'file_rec,file_rec/async,file_rec/git,file_mru,file,buffer,grep',
            \ 'ignore_pattern', join([
            \ '\.swp', '\.swo', '\~$',
            \ '\.git/', '\.svn/', '\.hg/',
            \ '\.ropeproject/',
            \ 'node_modules/', 'log/', 'tmp/', 'obj/',
            \ '/vendor/gems/', '/vendor/cache/', '\.bundle/', '\.sass-cache/',
            \ '/tmp/cache/assets/.*/sprockets/', '/tmp/cache/assets/.*/sass/',
            \ '\.pyc$', '\.class$', '\.jar$',
            \ '\.jpg$', '\.jpeg$', '\.bmp$', '\.png$', '\.gif$',
            \ '\.o$', '\.out$', '\.obj$', '\.rbc$', '\.rbo$', '\.gem$',
            \ '\.zip$', '\.tar\.gz$', '\.tar\.bz2$', '\.rar$', '\.tar\.xz$',
            \ '\.doc$', '\.docx$',
            \ 'target/',
            \ ], '\|'))

        " Grep
        if executable('ag')
            " Use ag in unite grep source.
            let g:unite_source_grep_command = 'ag'
            let g:unite_source_grep_default_opts =
                        \ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
                        \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
            let g:unite_source_grep_recursive_opt = ''
        elseif executable('pt')
            let g:unite_source_grep_command = 'pt'
            let g:unite_source_grep_default_opts = '--nogroup --nocolor'
            let g:unite_source_grep_recursive_opt = ''
        elseif executable('jvgrep')
            " For jvgrep.
            let g:unite_source_grep_command = 'jvgrep'
            let g:unite_source_grep_default_opts = '--exclude ''\.(git|svn|hg|bzr)'''
            let g:unite_source_grep_recursive_opt = '-R'
        elseif executable('ack-grep')
            " For ack.
            let g:unite_source_grep_command = 'ack-grep'
            let g:unite_source_grep_default_opts = '--no-heading --no-color -a'
            let g:unite_source_grep_recursive_opt = ''
        endif

        AutocmdFT unite call s:unite_settings()
        function! s:unite_settings()
            "imap <silent><buffer> <C-j> <Plug>(unite_select_next_line)
            imap <silent><buffer> <C-k> <Plug>(unite_select_previous_line)

            "imap <silent><buffer><expr> <C-v> unite#do_action('vsplit')
            imap <silent><buffer><expr> <C-t> unite#do_action('tabopen')

            nmap <buffer> <ESC> <Plug>(unite_exit)
            nmap <buffer> q <Plug>(unite_exit)

            imap <buffer>  jj      <Plug>(unite_insert_leave)

            let unite = unite#get_current_unite()
            if unite.profile_name ==# '^search'
                nnoremap <silent><buffer><expr> r unite#do_action('replace')
            else
                nnoremap <silent><buffer><expr> r unite#do_action('rename')
            endif

        endfunction
    endfunction "}}}

    " Unite {{{
    nnoremap [unite] <Nop>
    xnoremap [unite] <Nop>
    nmap <C-l> [unite]
    xmap <C-l> [unite]

    nnoremap <silent> [unite]o :split ~/.zsh_history<CR>
                \ :<C-u>Unite
                \ line<CR>

    " Source
    nnoremap <silent> [unite]u :<C-u>Unite source -vertical -silent -start-insert<CR>
    " Buffer
    nnoremap <silent> [unite]b :<C-u>Unite -silent buffer file_mru bookmark<CR>
    " File List
    nnoremap <silent> [unite]f :<C-u>UniteWithBufferDir -silent -buffer-name=files file<CR>
    " Register List
    nnoremap <silent> [unite]R :<C-u>Unite -silent -buffer-name=register register<CR>
    " Restore Unite
    nnoremap <silent> [unite]r         :<C-u>UniteResume<CR>
    " Yank History
    let g:unite_source_history_yank_enable = 1
    nnoremap <silent> [unite]y :<C-u>Unite -silent history/yank<CR>
    " Show Mapping List
    nnoremap <silent> [unite]ma :<C-u>Unite -silent mapping<CR>
    " Show Message
    nnoremap <silent> [unite]me :<C-u>Unite -silent output:message<CR>
    " Jump (mnemonic : <C-o> jump to Older cursor position)
    nnoremap <silent> [unite]<C-o> :<C-u>Unite -silent change jump<CR>
    " Grep
    nnoremap <silent> [unite]gr :<C-u>Unite -silent -no-quit grep:.<CR>
    " Line
    nnoremap <silent> g/ :<C-u>Unite -buffer-name=search line -start-insert -no-quit<CR>
    "-Unite Plugin Settings--------------"{{{
    " Execute help.
    nnoremap <silent> [unite]gh  :<C-u>Unite -silent -start-insert -buffer-name=help help<CR>
    " Outeline
    " nnoremap <silent> [unite]o :<C-u>Unite -silent outline -vertical -winwidth=40 -no-start-insert<CR>
    " Use outline like explorer
    nnoremap <silent> [unite]o :<C-u>Unite
                \ -no-quit -keep-focus -no-start-insert
                \ -vertical -direction=botright -winwidth=40 outline<CR>
    " Fold
    nnoremap <silent> [unite]z :<C-u>Unite -silent fold -vertical -winwidth=40 -no-start-insert<CR>
    " Unite Beautiful Atack
    nnoremap <silent> [unite]C :<C-u>Unite -auto-preview colorscheme<CR>
    " Git repository
    nnoremap <silent> [unite]<Space> :<C-u>Unite file_rec/async:! -start-insert<CR>
    "nnoremap <silent> <Space><Space> :<C-u>Unite file_rec/git -start-insert<CR>
    " runtimepath
    "nnoremap <silent> [unite]v :<C-u>Unite runtimepath -start-insert -default-action=vimshell<CR>
    " neobundle
    nnoremap <silent> [unite]n :<C-u>Unite neobundle -start-insert -default-action=vimshell<CR>
    " nnoremap <silent> [unite]n :<C-u>Unite neobundle -start-insert -default-action=rec_project/async<CR>
    "}}}
    "}}}

    call neobundle#untap()
endif
"}}}

" unite-sources {{{
" Shougo/unite-help {{{
if neobundle#tap('unite-help')
    call neobundle#config({
        \   'autoload' : {
        \     'unite_sources' : [
        \       'help'
        \     ],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}
" ujihisa/unite-colorscheme {{{
if neobundle#tap('unite-colorscheme')
    call neobundle#config({
        \   'autoload' : {
        \     'unite_sources' : [
        \       'colorscheme'
        \     ],
        \   }
        \ })
    command! -nargs=* BeautifulAttack Unite colorscheme -auto-preview -winheight=3
    call neobundle#untap()
endif
"}}}
" Shougo/unite-outline {{{
if neobundle#tap('unite-outline')
    call neobundle#config({
        \   'autoload' : {
        \     'unite_sources' : [
        \       'outline'
        \     ],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}
" osyo-manga/unite-fold {{{
if neobundle#tap('unite-fold')
    call neobundle#config({
        \   'autoload' : {
        \     'unite_sources' : [
        \       'fold'
        \     ],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}
" kmnk/vim-unite-giti {{{
if neobundle#tap('vim-unite-giti')
    call neobundle#config({
        \   'autoload' : {
        \     'unite_sources' : [
        \       'giti',
        \       'giti/status'
        \     ],
        \   }
        \ })
    call neobundle#untap()
    nnoremap <silent> [unite]gg :<C-u>Unite giti/status -winheight=10
                \   -no-start-insert -no-quit<CR>
endif
"}}}
" thinca/vim-unite-history {{{
if neobundle#tap('vim-unite-history')
    call neobundle#config({
        \   'autoload' : {
        \     'unite_sources' : [
        \       'history'
        \     ],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}
" osyo-manga/unite-quickfix {{{
if neobundle#tap('unite-quickfix')
    call neobundle#config({
        \   'autoload' : {
        \     'unite_sources' : [
        \       'quickfix'
        \     ],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}
" moznion/unite-git-conflict {{{
if neobundle#tap('unite-git-conflict')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'unite_sources' : [
                \       'git-conflict',
                \     ],
                \   }
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
    endfunction "}}}
    " Setting {{{
    "}}}
    call neobundle#untap()
endif
" }}}
" Shougo/unite-session {{{
if neobundle#tap('unite-session')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'unite_sources' : [
                \       'session',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}
" osyo-manga/unite-vimpatches {{{
if neobundle#tap('unite-vimpatches')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'unite_sources' : [
                \       'vimpatches',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}
" tsukkee/unite-tag {{{
if neobundle#tap('unite-tag')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'unite_sources' : [
                \       'tag',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" action
" osyo-manga/ref-lynx {{{
if neobundle#tap('ref-lynx')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'unite_sources' : [
                \       'ref-lynx',
                \     ],
                \   }
                \ })
    " }}}
    " call unite#custom#default_action('uri', 'ref-lynx')

    call neobundle#untap()
endif
" }}}
" haya14busa/unite-action-vimfiler_lcd {{{
if neobundle#tap('unite-action-vimfiler_lcd')
    call neobundle#config({'depends' : 'Shougo/unite.vim'})
    call neobundle#untap()
endif
" }}}
" osyo-manga/unite-vital-module {{{
if neobundle#tap('unite-vital-module')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'unite_sources' : [
                \       'vital-module',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" End unite-sources }}}

" Shougo/VimFiler {{{
if neobundle#tap('vimfiler.vim')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \    'commands' : [
                \       { 'name' : 'VimFiler',
                \         'complete' : 'customlist,vimfiler#complete' },
                \       { 'name' : 'VimFilerTab',
                \         'complete' : 'customlist,vimfiler#complete' },
                \       { 'name' : 'VimFilerBufferDir',
                \         'complete' : 'customlist,vimfiler#complete' },
                \       { 'name' : 'VimFilerExplorer',
                \         'complete' : 'customlist,vimfiler#complete' },
                \       { 'name' : 'Edit',
                \         'complete' : 'customlist,vimfiler#complete' },
                \       { 'name' : 'Write',
                \         'complete' : 'customlist,vimfiler#complete' },
                \       'Read', 'Source'],
                \    'mappings' : '<Plug>(vimfiler_',
                \    'explorer' : 1,
                \   }
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        hi link exrenameModified Normal
        let g:vimfiler_as_default_explorer=1

        "nnoremap [vimfiler]  <Nop>
        "nmap     <space>  [vimfiler]

        "nnoremap <silent> [vimfiler]f   :<C-u>VimFiler -buffer-name=explorer -split -simple -winwidth=35 -toggle -no-quit<CR>
        "nnoremap <silent> [vimfiler]t   :<C-u>VimFilerTab -double -no-quit<CR>
        "nnoremap <silent> [vimfiler]b   :<C-u>VimFiler -buffer-name=explorer -split -simple -winwidth=35 -toggle -no-quit -auto-cd $VIMBUNDLE<CR>

        let g:vimfiler_as_default_explorer = 1
        let g:vimfiler_enable_auto_cd = 1

        if has('win32')
            let g:unite_kind_file_use_trashbox = 1
        endif

        "call s:LetAndMkdir('g:vimfiler_data_directory', $DOTVIM.'/.vimfiler')

        if has('mac')
            let g:vimfiler_tree_leaf_icon = ' '
            let g:vimfiler_tree_opened_icon = '▾'
            let g:vimfiler_tree_closed_icon = '▸'
            let g:vimfiler_file_icon = '-'
            let g:vimfiler_marked_file_icon = '*'
        else
            let g:vimfiler_tree_leaf_icon = ' '
            let g:vimfiler_tree_opened_icon = '-'
            let g:vimfiler_tree_closed_icon = '+'
            let g:vimfiler_file_icon = '-'
            let g:vimfiler_marked_file_icon = '*'
        endif

        AutocmdFT vimfiler call <SID>my_vimfiler_settings()

        function! <SID>my_vimfiler_settings()
            if has('gui')
                nnoremap <silent><buffer><expr> E  vimfiler#do_action('tabdrop')
            else
                nnoremap <silent><buffer><expr> E  vimfiler#do_action('tabopen')
            endif
            nnoremap <silent><buffer><expr> s  vimfiler#do_action('right')
            nnoremap <silent><buffer><expr> f  vimfiler#do_action('diff')

            "nmap <buffer> <Space>           <Nop>
            nmap <buffer> <Leader><Leader>  <Plug>(vimfiler_toggle_mark_current_line)
            vmap <buffer> <Leader><Leader>  <Plug>(vimfiler_toggle_mark_selected_lines)
            nmap <buffer>' <Plug>(vimfiler_toggle_mark_current_line)
            xmap <buffer>' <Plug>(vimfiler_toggle_mark_selected_lines)
            map <buffer> t :call vimfiler#mappings#do_action('tabopen')<CR>
        endfunction
    endfunction "}}}

    let g:vimfiler_safe_mode_by_default=0
    nnoremap <silent> mf :VimFilerBufferDir -split -simple -no-quit -winwidth=32<CR>
    "nnoremap <silent> ;vf :VimFilerBufferDir -split -simple -no-quit -winwidth=32<CR>
    nnoremap <silent> ;vt :VimFilerBufferDir -tab<CR>
    "    au VimEnter * VimFilerBufferDir -split -simple -toggle -no-quit -winwidth=32

    call neobundle#untap()
endif
"}}}

" Shougo/vimshell.vim {{{
if neobundle#tap('vimshell.vim')
    call neobundle#config({
        \   'depends': ['Shougo/vimproc'],
        \   'autoload' : {
        \       'commands' : [
        \       { 'name' : 'VimShell',
        \         'complete' : 'customlist,vimshell#complete'},
        \       { 'name' : 'VimShellTab',
        \         'complete' : 'customlist,vimshell#complete'},
        \       { 'name' : 'VimShellBufferDir',
        \         'complete' : 'customlist,vimshell#complete'},
        \       { 'name' : 'VimShellCreate',
        \         'complete' : 'customlist,vimshell#complete'},
        \         'VimShellExecute', 'VimShellInteractive',
        \         'VimShellTerminal', 'VimShellPop'],
        \   }
        \ })
    function! neobundle#tapped.hooks.on_source(bundle)
        " Use current directory as vimshell prompt.
        let g:vimshell_prompt_expr =
                    \ 'escape(fnamemodify(getcwd(), ":~").">", "\\[]()?! ")." "'
        let g:vimshell_prompt_pattern = '^\%(\f\|\\.\)\+> '
        let g:vimshell_right_prompt = 'vcs#info("(%s)-[%b]%p", "(%s)-[%b|%a]%p")'
    endfunction

    call neobundle#untap()
endif
"}}}

" Shougo/neosnippet.vim "{{{
if neobundle#tap('neosnippet.vim')
    call neobundle#config({
        \   'autoload' : {
        \     'insert' : 1,
        \     'filetypes' : 'neosnippet',
        \     'unite_sources' : [
        \       'snippet', 'neosnippet/user', 'neosnippet/runtime'
        \       ],
        \   }
        \ })

    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        " For snippet_complete marker.
        if has('conceal')
            set conceallevel=2 concealcursor=i
        endif
        " Enable snipMate compatibility feature.
        let g:neosnippet#enable_snipmate_compatibility = 1
        " Remove snippets marker automatically
        Autocmd InsertLeave * :NeoSnippetClearMarkers

        "prioratise snippet
        call neocomplete#custom#source('neosnippet', 'rank', 400)

        snoremap <Esc> <Esc>:NeoSnippetClearMarkers<CR>
    endfunction "}}}

    " haya14busa-snippets {{{
    let g:neosnippet#snippets_directory=$HOME.'/.vim/mybundle/haya14busa-snippets/neosnippets'
    "}}}

    " SuperTab like snippets behavior.
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
                \ "\<Plug>(neosnippet_expand_or_jump)"
                \: pumvisible() ? "\<C-n>" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
                \ "\<Plug>(neosnippet_expand_or_jump)"
                \: "\<TAB>"

    " Plugin key-mappings.
    imap <C-k> <Plug>(neosnippet_expand_or_jump)
    smap <C-k> <Plug>(neosnippet_expand_or_jump)
    xmap <C-k> <Plug>(neosnippet_expand_target)
    xmap <C-l> <Plug>(neosnippet_start_unite_snippet_target)

    call neobundle#untap()
endif
"}}}

" Shougo/neocomplete.vim"{{{
if neobundle#tap('neocomplete.vim')
    call neobundle#config({
        \   'autoload' : {
        \     'insert' : 1,
        \   }
        \ })
    function! neobundle#tapped.hooks.on_source(bundle)
        " Use smartcase.
        let g:neocomplete#enable_smart_case = 1
        let g:neocomplete#enable_camel_case = 1
        let g:neocomplete#enable_underbar_completion = 1

        " Use fuzzy completion.
        let g:neocomplete#enable_fuzzy_completion = 1

        " Set minimum syntax keyword length.
        let g:neocomplete#sources#syntax#min_keyword_length = 3
        " Set auto completion length.
        let g:neocomplete#auto_completion_start_length = 2
        " Set manual completion length.
        let g:neocomplete#manual_completion_start_length = 0
        " Set minimum keyword length.
        let g:neocomplete#min_keyword_length = 3

        " Set neosnippet competion length.
        call neocomplete#custom#source('neosnippet', 'min_pattern_length', 1)

        let g:neocomplete#disable_auto_select_buffer_name_pattern =
                    \ '\[Command Line\]'

        " Enable omni completion.
        AutocmdFT css setlocal omnifunc=csscomplete#CompleteCSS
        AutocmdFT html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
        " AutocmdFT javascript setlocal omnifunc=javascriptcomplete#CompleteJS
        AutocmdFT javascript setlocal omnifunc=tern#Complete
        AutocmdFT coffee setlocal omnifunc=javascriptcomplete#CompleteJS
        AutocmdFT xml setlocal omnifunc=xmlcomplete#CompleteTags
        AutocmdFT python setlocal omnifunc=jedi#completions

        if !exists('g:neocomplete#force_omni_input_patterns')
            let g:neocomplete#force_omni_input_patterns = {}
        endif
        let g:jedi#auto_vim_configuration = 0
        let g:neocomplete#force_omni_input_patterns.python =
                    \ '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
        let g:neocomplete#sources#dictionary#dictionaries = {
            \ 'default' : '',
            \ 'vimshell' : $HOME.'/.vimshell_hist',
            \ 'scala' : $HOME.'/.vim/myplugin/vim-scala-dict/dict/scala.dict',
            \ }
    endfunction
    " Use neocomplete.
    let g:neocomplete#enable_at_startup = 1

    " Plugin key-mappings.
    inoremap <expr><C-g>     neocomplete#undo_completion()
    inoremap <expr><C-l>     neocomplete#complete_common_string()

    " <Tab>: completion
    " inoremap <expr><Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
    " inoremap <expr><S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

    " <C-f>, <C-b>: page move.
    " inoremap <expr><C-f>  pumvisible() ? "\<PageDown>" : "\<Right>"
    " inoremap <expr><C-b>  pumvisible() ? "\<PageUp>"   : "\<Left>"
    " <C-y>: paste.
    " inoremap <expr><C-y>  pumvisible() ? neocomplete#close_popup() :  "\<C-r>\""
    " <C-e>: close popup.
    inoremap <expr><C-e>  pumvisible() ? neocomplete#cancel_popup() : "\<End>"

    call neobundle#untap()
endif
"}}}

" Shougo/neocomplcache.vim"{{{
if neobundle#tap('neocomplcache.vim')
    call neobundle#config({
        \   'autoload' : {
        \     'insert' : 1,
        \   }
        \ })
    function! neobundle#tapped.hooks.on_source(bundle)
        let g:neocomplcache_enable_smart_case = 1
    endfunction
    call neobundle#untap()
endif
"}}}

" thinca/vim-quickrun {{{
if neobundle#tap('vim-quickrun')
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : 'QuickRun',
        \     'mappings' : ['<Plug>(quickrun)'],
        \   }
        \ })
    function! neobundle#tapped.hooks.on_source(bundle)
        let g:quickrun_config = {
                    \   "_" : {
                    \       "runner" : "vimproc",
                    \       "runner/vimproc/updatetime" : 500
                    \   },
                    \   "watchdogs_checker/_" : {
                    \       'outputter/quickfix/open_cmd' : '',
                    \   },
                    \}
                    " \       "runner/vimproc/updatetime" : 60
        let g:quickrun_config.markdown = {
                    \ 'type': 'markdown/pandoc',
                    \ 'cmdopt': '-s',
                    \ 'outputter': 'browser'
                    \ }
    endfunction
    nnoremap <Leader>q  <Nop>
    nnoremap <silent><Leader>qr :<C-u>QuickRun<CR>
    vnoremap <silent><Leader>qr :QuickRun<CR>

    call neobundle#untap()
endif
"}}}

" thinca/vim-scouter"{{{
if neobundle#tap('vim-scouter')
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : 'Scouter',
        \   }
        \ })
    call neobundle#untap()
endif
"}}}

" thinca/vim-ref {{{
if neobundle#tap('vim-ref')
    call neobundle#config({
        \   'autoload' : {
        \     'commands' :
        \       [{'name': 'Ref',
        \         'complete': 'customlist,ref#complete'},],
        \     'unite_sources' : ['ref'],
        \   }
        \ })
    function! neobundle#tapped.hooks.on_source(bundle)
        let g:ref_jquery_doc_path = $HOME . '/.vim/.bundle/jqapi'
        let g:ref_javascript_doc_path = $HOME . '/.vim/.bundle/jsref/htdocs'
        let g:ref_wikipedia_lang = ['ja', 'en']
        let g:ref_use_cache = 1
        let g:ref_source_webdict_sites = {
            \   'je': {
            \     'url': 'http://eow.alc.co.jp/search?q=%s&ref=sa',
            \   },
            \   'ej': {
            \     'url': 'http://eow.alc.co.jp/search?q=%s&ref=sa',
            \   },
            \   'etm': {
            \     'url': 'http://home.alc.co.jp/db/owa/etm_sch?stg=1&instr=%s',
            \   },
            \   'wiki': {
            \     'url': 'http://ja.wikipedia.org/wiki/%s',
            \   },
            \ }
        let g:ref_alc_encoding = 'utf-8'
    endfunction
    call neobundle#untap()
endif
"}}}

" cohama/agit.vim {{{
if neobundle#tap('agit.vim')
    call neobundle#config({
    \ 'depends': ['tpope/vim-fugitive'],
    \ 'autoload': {
    \   'commands' : ['Agit']
    \   }
    \ })

    call neobundle#untap()
endif
"}}}

" mattn/emmet-vim"{{{
if neobundle#tap('emmet-vim')
    call neobundle#config({
        \   'autoload' : {
        \     'filetypes' : [
        \       'html',
        \       'xhttml',
        \       'css',
        \       'sass',
        \       'scss',
        \       'styl',
        \       'xml',
        \       'xls',
        \       'markdown',
        \       'htmldjango',
        \     ]},
        \ })
    call neobundle#untap()
endif
"}}}

"" mattn/gist-vim"{{{
"if neobundle#tap('gist-vim')
"    call neobundle#config({
"        \   'autoload' : {
"        \     'commands' : [
"        \       'Gist',
"        \     ]},
"        \ })
"    call neobundle#untap()
"endif
"}}}


" vim-easymotion {{{
if neobundle#tap('vim-easymotion')
    call neobundle#config({
          \   'autoload' : {
          \     'mappings' : [['sxno', '<Plug>(easymotion-']],
          \     'functions' : [
          \       'EasyMotion#User',
          \       'EasyMotion#JK',
          \       'EasyMotion#is_active',
          \     ],
          \   }
          \ })
    function! neobundle#tapped.hooks.on_post_source(bundle) "{{{
        "EMCommandLineNoreMap ; <CR>
        "EMCommandLineNoreMap <Space> <CR>
        EMCommandLineNoreMap <Space> <CR>
        EMCommandLineNoreMap <C-j> <Space>
        "map <space> <Plug>(easymotion-prefix)
        if ! g:EasyMotion_do_shade
            highlight! link EasyMotionIncSearch IncSearch
        endif
        highlight! link EasyMotionMoveHL Search
    endfunction "}}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        " EasyMotion Config {{{
        let g:EasyMotion_do_mapping = 0
        " let g:EasyMotion_keys = ';HKLYUIOPNM,QWERTZXCVBASDGJF'
        let g:EasyMotion_keys = 'jkf.,hklyuiopnmqwertzxcvbasdg'
        " Do not shade
        let g:EasyMotion_do_shade = 0
        " Use upper case
        let g:EasyMotion_use_upper = 1
        " Smartcase
        let g:EasyMotion_smartcase = 1
        " Smartsign
        let g:EasyMotion_use_smartsign_us = 1
        " keep cursor column
        let g:EasyMotion_startofline = 0
        " Don't skip folded line
        let g:EasyMotion_skipfoldedline = 0
        " pseudo-migemo
        let g:EasyMotion_use_migemo = 1
        " Jump to first with enter & space
        " let g:EasyMotion_enter_jump_first = 1
        let g:EasyMotion_space_jump_first = 1
        " Prompt
        let g:EasyMotion_prompt = '{n}> '
        " Highlight cursor
        " let g:EasyMotion_cursor_highlight = 1
        "}}}

        " EasyMotion Regrex {{{
        let g:EasyMotion_re_line_anywhere = '\v' .
                    \  '(<.|^.)' . '|' .
                    \  '(.>|.$)' . '|' .
                    \  '(\s+\zs.)' . '|' .
                    \  '(\l)\zs(\u)' . '|' .
                    \  '(_\zs.)' . '|' .
                    \  '(#\zs.)'
        let g:EasyMotion_re_anywhere = '\v' .
                    \  '(<.|^)' . '|' .
                    \  '(.$)' . '|' .
                    \  '(\s+\zs.)' . '|' .
                    \  '(\l)\zs(\u)' . '|' .
                    \  '(_\zs.)' . '|' .
                    \  '(/\zs.)' . '|' .
                    \  '(#\zs.)'
        "}}}

    endfunction "}}}

    " EasyMotion Mapping {{{
    nmap s <Plug>(easymotion-s2)
    vmap s <Plug>(easymotion-s2)
    omap z <Plug>(easymotion-s2)
    nmap ms <Plug>(easymotion-s)
    vmap ms <Plug>(easymotion-s)
    omap mz <Plug>(easymotion-s)

    " Extend search
    "map  / <Plug>(easymotion-sn)
    "xmap / <Esc><Plug>(easymotion-sn)\v%V
    "omap / <Plug>(easymotion-tn)
    "noremap  ;/ /
    " nmap ;n <Plug>(easymotion-sn)<C-p>
    " map ;N <Plug>(easymotion-bd-n)

    set nohlsearch " use EasyMotion highlight
    "nmap n <Plug>(easymotion-next)<Plug>(anzu-update-search-status)zv
    "nmap N <Plug>(easymotion-prev)<Plug>(anzu-update-search-status)zv
    "xmap n <Plug>(easymotion-next)zv
    "xmap N <Plug>(easymotion-prev)zv

    " Replace defaut
    " smart f & F
    omap f <Plug>(easymotion-bd-fl)
    xmap f <Plug>(easymotion-bd-fl)
    omap F <Plug>(easymotion-Fl)
    xmap F <Plug>(easymotion-Fl)
    omap t <Plug>(easymotion-tl)
    xmap t <Plug>(easymotion-tl)
    omap T <Plug>(easymotion-Tl)
    xmap T <Plug>(easymotion-Tl)

    " Extend hjkl
    "map ;h <Plug>(easymotion-linebackward)
    "map ;j <Plug>(easymotion-j)
    "map ;k <Plug>(easymotion-k)
    "map ;l <Plug>(easymotion-lineforward)
    "map mh <Plug>(easymotion-linebackward)
    "map mj <Plug>(easymotion-j)
    "map mk <Plug>(easymotion-k)
    "map <CR> <CR>$
    "map <CR> H<Plug>(easymotion-j)$
    "map ml <Plug>(easymotion-lineforward)
    map <CR> H<Plug>(easymotion-j)
    map ml H<Plug>(easymotion-j)
    map  <Space>  <Plug>(easymotion-bd-el)
    map  mm  <Plug>(easymotion-bd-wl)

    " Anywhere!
    " map <Space><Space> <Plug>(easymotion-jumptoanywhere)

    " Repeat last motion
    " map ;<Space> <Plug>(easymotion-repeat)

    " move to next/previous last motion match
    "nmap <expr> <C-n> yankround#is_active() ?
    "            \ '<Plug>(yankround-next)' : '<Plug>(easymotion-next)'
    "nmap <expr> <C-p> yankround#is_active() ?
    "            \ '<Plug>(yankround-prev)' : '<Plug>(easymotion-prev)'
    xmap <C-n> <Plug>(easymotion-next)
    xmap <C-p> <Plug>(easymotion-prev)

    nmap <expr><Tab> EasyMotion#is_active() ?
                \ '<Plug>(easymotion-next)' : '<TAB>'
    nmap <expr>' EasyMotion#is_active() ?
                \ '<Plug>(easymotion-prev)' : "'"

    " Extene word motion
    "map  me  0<Plug>(easymotion-bd-wl)
    "map  <Space>  0<Plug>(easymotion-bd-wl)
    "map  mw  <Plug>(easymotion-bd-el)
    "omap mb  <Plug>(easymotion-bl)
    " omap ;ge <Plug>(easymotion-gel)
    "map mge <Plug>(easymotion-gel)
    "map jk <CR>
    

    function! s:wrap_M()
        let current_line = getline('.')
        keepjumps normal! M
        let middle_line = getline('.')
        if current_line == middle_line
            call EasyMotion#JK(0,2)
        endif
    endfunction
    nnoremap <silent> M :<C-u>call <SID>wrap_M()<CR>
    "}}}

    " EasyMotion User {{{
    " EasyMotion#User(pattern, is_visual, direction, is_inclusive)
    noremap  <silent><expr>;c
                \ ':<C-u>call EasyMotion#User(' .
                \ '"\\<' . expand('<cword>') . '\\>", 0, 2, 1)<CR>'
    xnoremap  <silent><expr>;c
                \ '<ESC>:<C-u>call EasyMotion#User(' .
                \ '"\\<' . expand('<cword>') . '\\>", 1, 2, 1)<CR>'

    let g:empattern = {}
    let g:empattern['syntax'] = '\v'
                \ . 'function|endfunction|return|call'
                \ . '|if|elseif|else|endif'
                \ . '|for|endfor'
                \ . '|while|endwhile'
                \ . '|break|continue'
                \ . '|let|unlet'
                \ . '|noremap|map|expr|silent'
                \ . '|g:|s:|b:|w:'
                \ . '|autoload|#|plugin'

    noremap  <silent>;1
                \ :<C-u>call EasyMotion#User(g:empattern.syntax , 0, 2, 1)<CR>
    xnoremap <silent>;1
                \ :<C-u>call EasyMotion#User(g:empattern.syntax , 1, 2, 1)<CR>
    "}}}

    function! EasyMotionMigemoToggle() "{{{
        if !exists(g:EasyMotion_use_migemo) && g:EasyMotion_use_migemo == 1
            let g:EasyMotion_use_migemo = 0
            echo 'Turn Off migemo'
        else
            let g:EasyMotion_use_migemo = 1
            echo 'Turn On migemo'
        endif
    endfunction
    command! -nargs=0 EasyMotionMigemoToggle :call EasyMotionMigemoToggle() "}}}

    call neobundle#untap()
endif
"}}}

" haya14busa/vim-easyoperator-line {{{
if neobundle#tap('vim-easyoperator-line')
    " Config {{{
    call neobundle#config({
                \   'depends' : 'vim-easymotion',
                \   'autoload' : {
                \     'mappings' : [
                \       '<Plug>(easyoperator-line-',
                \     ],
                \   }
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
    endfunction "}}}
    " Setting {{{
    "xmap ml  <Plug>(easyoperator-line-select)
    "omap ml  <Plug>(easyoperator-line-select)
    nmap dml <Plug>(easyoperator-line-delete)
    nmap yml <Plug>(easyoperator-line-yank)
    "}}}
    call neobundle#untap()
endif
" }}}

" haya14busa/vim-easyoperator-phrase {{{
if neobundle#tap('vim-easyoperator-phrase')
    " Config {{{
    call neobundle#config({
                \   'depends' : 'vim-easymotion',
                \   'autoload' : {
                \     'mappings' : [
                \       '<Plug>(easyoperator-phrase-',
                \     ],
                \   }
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
    endfunction "}}}
    " Setting {{{
    "xmap mp  <Plug>(easyoperator-phrase-select)
    "omap mp  <Plug>(easyoperator-phrase-select)
    "nmap dmp <Plug>(easyoperator-phrase-delete)
    "nmap ymp <Plug>(easyoperator-phrase-yank)
    "}}}
    call neobundle#untap()
endif
" }}}

" haya14busa/vim-lazy-lines {{{
if neobundle#tap('vim-lazy-lines')
    " Config {{{
    call neobundle#config({
                \   'depends' : 'vim-easymotion',
                \   'autoload' : {
                \     'mappings' : [
                \       '<Plug>(lazy-',
                \     ],
                \   }
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
    endfunction "}}}
    " Setting {{{
    nmap dmj <Plug>(lazy-deletelines)
    "nmap dmk <Plug>(lazy-deletelines-k)
    " nmap d;j <Plug>(lazy-deletelines-j)

    "}}}
    call neobundle#untap()
endif
" }}}

" gista {{{
let g:gista#github_user = 'syui'
" }}}

" clever-f.vim {{{

if neobundle#tap('clever-f.vim')
    call neobundle#config({
        \   'autoload' : {
        \     'mappings' : [['sxno','<Plug>(clever-f-']],
        \   }
        \ })
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        let g:clever_f_not_overwrites_standard_mappings = 1
        let g:clever_f_smart_case = 1
        let g:clever_f_across_no_line = 1
    endfunction "}}}
    nmap f <Plug>(clever-f-f)
    nmap F <Plug>(clever-f-F)
endif
"}}}

" TextObject Keymaps{{{
" vim-textobj-entire {{{
if neobundle#tap('vim-textobj-entire')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'ae'], ['xo', 'ie']]
        \   }
        \ })
    call neobundle#untap()
endif
" }}}
" vim-textobj-fold {{{
if neobundle#tap('vim-textobj-fold')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'az'], ['xo', 'iz']]
        \   }
        \ })
    call neobundle#untap()
endif
" }}}
" vim-textobj-indent {{{
if neobundle#tap('vim-textobj-indent')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'ai'], ['xo', 'aI'], ['xo', 'ii'], ['xo', 'iI']]
        \   }
        \ })
    call neobundle#untap()
endif
" }}}
" vim-textobj-line {{{
if neobundle#tap('vim-textobj-line')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'al'], ['xo', 'il']]
        \   }
        \ })
    call neobundle#untap()
endif
" }}}
" vim-textobj-syntax {{{
if neobundle#tap('vim-textobj-syntax')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'ay'], ['xo', 'iy']]
        \   }
        \ })
    call neobundle#untap()
endif
" }}}
" vim-textobj-django-template {{{
if neobundle#tap('vim-textobj-django-template')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'adb'], ['xo', 'idb']]
        \   }
        \ })
    call neobundle#untap()
endif
" }}}
" vim-textobj-between {{{
if neobundle#tap('vim-textobj-between')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'af'], ['xo', 'if'], ['xo', '<Plug>(textobj-between-']]
        \   }
        \ })
    call neobundle#untap()
endif
" }}}
" vim-textobj-url {{{
if neobundle#tap('vim-textobj-url')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'au'], ['xo', 'iu']]
        \   }
        \ })
    call neobundle#untap()
endif
" }}}
" vim-textobj-multiblock {{{
if neobundle#tap('vim-textobj-multiblock')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'ab'], ['xo', 'ib'], ['xo', '<Plug>(textobj-multiblock-']]
        \   }
        \ })
    omap ib <Plug>(textobj-multiblock-i)
    omap ab <Plug>(textobj-multiblock-a)
    vmap ib <Plug>(textobj-multiblock-i)
    vmap ab <Plug>(textobj-multiblock-a)
    call neobundle#untap()
endif
" }}}
" vim-textobj-underscore {{{
if neobundle#tap('vim-textobj-underscore')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'a_'], ['xo', 'i_']]
        \   }
        \ })
    call neobundle#untap()
endif
" }}}
" vim-textobj-number {{{
if neobundle#tap('vim-textobj-number')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'an'], ['xo', 'in']]
        \   }
        \ })
    call neobundle#untap()
endif
" }}}
" textobj-wiw {{{
if neobundle#tap('textobj-wiw')
    call neobundle#config({
        \ 'depends' : 'kana/vim-textobj-user',
        \ 'autoload' : {
        \       'mappings' : [['xo', 'a,w'], ['xo', 'i,w']]
        \   }
        \ })
    call neobundle#untap()
endif
" }}}

"}}}

" kana/vim-operator-replace "{{{
if neobundle#tap('vim-operator-replace')
    call neobundle#config({
        \ 'depends' : 'kana/vim-operator-user',
        \   'autoload' : {
        \     'mappings' : '<Plug>(operator-replace)'
        \   }
        \ })
    map ;R  <Plug>(operator-replace)
    call neobundle#untap()
endif
" }}}

" rhysd/vim-operator-surround {{{
if neobundle#tap('vim-operator-surround')
    map <silent>ys <Plug>(operator-surround-append)
    map <silent>ds <Plug>(operator-surround-delete)
    map <silent>cs <Plug>(operator-surround-replace)
    nmap <silent>yss V<Plug>(operator-surround-append)
    nmap <silent>dss V<Plug>(operator-surround-delete)
    nmap <silent>css V<Plug>(operator-surround-replace)
    call neobundle#untap()
endif
"}}}

" osyo-manga/vim-anzu {{{
if neobundle#tap('vim-anzu')
    call neobundle#config({
        \   'autoload' : {
        \     'mappings' : ['<Plug>(anzu-'],
        \   }
        \ })
    "nmap n <Plug>(anzu-n)zzzv
    "nmap N <Plug>(anzu-N)zzzv
    nmap N <Plug>(anzu-N)zzzv
    nmap * <Plug>(anzu-star-with-echo)
    " nmap # <Plug>(anzu-sharp-with-echo)

    " Clear hit count when nokeyinput, move window, or move tab
    Autocmd CursorHold,CursorHoldI,WinLeave,TabLeave
                \   * call anzu#clear_search_status()
    call neobundle#untap()
endif
"}}}

" Yggdroot/indentLine {{{
if neobundle#tap('indentLine')
    let g:indentLine_color_term = 239
    function! neobundle#tapped.hooks.on_source(bundle)
        Autocmd InsertEnter * IndentLinesDisable
        Autocmd InsertLeave * IndentLinesEnable
    endfunction
    call neobundle#untap()
endif
" }}}

" jedi-vim {{{
"if neobundle#tap('jedi-vim')
"    call neobundle#config({
"        \ "autoload": {
"        \   "filetypes": ["python", "python3", "djangohtml"],
"        \ },
"        \ "build": {
"        \   "mac": "pip install jedi",
"        \   "unix": "pip install jedi",
"        \ }})
"    function! neobundle#tapped.hooks.on_source(bundle) "{{{
"        " Disable automatically set completeopt+=preview
"        let g:jedi#auto_vim_configuration = 0
"        " Disable automatically select the first entry that pops up
"        let g:jedi#popup_select_first = 0
"        " Disable automatically starts completion upon typing a period
"        let g:jedi#popup_on_dot = 0
"        " For quickrun
"        let g:jedi#rename_command = '<Leader>R'
"        " For gundo
"        let g:jedi#goto_assignments_command = '<Leader>G'
"        let g:jedi#completions_command = "<C-N>"
"    endfunction "}}}
"    call neobundle#untap()
"endif
""}}}

" sjl/gundo.vim" {{{
if neobundle#tap('gundo.vim')
    call neobundle#config({
        \ "autoload": {
        \   "commands": ['GundoToggle'],
        \}})
    nnoremap <Leader>g :<C-u>GundoToggle<CR>
    call neobundle#untap()
endif
"}}}

" tyru/open-browser {{{
if neobundle#tap('open-browser.vim')
    call neobundle#config({
        \ 'autoload' : {
        \   'mappings' : '<Plug>(openbrowser-smart-search)',
        \   'commands' : [
        \     'OpenBrowserSmartSearch',
        \     'OpenBrowser',
        \   ]},
        \ })
    " If it looks like URI, open an URI under cursor.
    " Otherwise, search a word under cursor.
    nmap <Leader>o <Plug>(openbrowser-smart-search)
    " If it looks like URI, open selected URI.
    " Otherwise, search selected word.
    vmap <Leader>o <Plug>(openbrowser-smart-search)
    call neobundle#untap()
endif
"}}}

" tyru/open-browser-github {{{
if neobundle#tap('open-browser-github.vim')
    " Config {{{
    call neobundle#config({
                \   'depends' :
                \     ['tyru/open-browser.vim'],
                \   'autoload' : {
                \     'commands' : [
                \       'OpenGithubFile', 'OpenGithubIssue', 'OpenGithubPullReq'
                \     ],
                \   }
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
    endfunction "}}}
    " Setting {{{
    "}}}
    call neobundle#untap()
endif
" }}}

"" lightline.vim {{{
"if neobundle#tap('lightline.vim')
"    " lightline setting {{{
"    let g:lightline = {
"        \ 'colorscheme': 'wombat',
"        \ 'mode_map': {
"        \   'n' : 'N',
"        \   'i' : 'I',
"        \   'R' : 'R',
"        \   'v' : 'V',
"        \   'V' : 'V-L',
"        \   'c' : 'COMMAND',
"        \   "\<C-v>": 'V-B',
"        \   's' : 'SELECT',
"        \   'S' : 'S-L',
"        \   "\<C-s>": 'S-B',
"        \   '?': '      '
"        \ },
"        \ 'active': {
"        \   'left': [
"        \       [ 'mode', 'paste' ],
"        \       [ 'filename','fugitive','anzu'],
"        \   ],
"        \   'right': [
"        \       [ 'percent' ],
"        \       [ 'filetype'],
"        \   ]
"        \ },
"        \ 'component_function': {
"        \   'modified': 'MyModified',
"        \   'readonly': 'MyReadonly',
"        \   'fugitive': 'MyFugitive',
"        \   'filename': 'MyFilename',
"        \   'fileformat': 'MyFileformat',
"        \   'filetype': 'MyFiletype',
"        \   'fileencoding': 'MyFileencoding',
"        \   'mode': 'MyMode',
"        \   'anzu': 'anzu#search_status',
"        \ }
"        \ }
"    "}}}
"
"    function! neobundle#tapped.hooks.on_source(bundle) "{{{
"        let g:unite_force_overwrite_statusline = 0
"        let g:vimfiler_force_overwrite_statusline = 0
"        let g:vimshell_force_overwrite_statusline = 0
"    endfunction "}}}
"
"    function! MyModified() "{{{
"        return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
"    endfunction "}}}
"
"    function! MyReadonly() "{{{
"        return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
"    endfunction "}}}
"
"    function! MyFilename() "{{{
"        return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
"            \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
"            \  &ft == 'unite' ? unite#get_status_string() :
"            \  &ft == 'vimshell' ? vimshell#get_status_string() :
"            \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
"            \ ('' != MyModified() ? ' ' . MyModified() : '')
"    endfunction "}}}
"
"    function! MyFugitive() "{{{
"        try
"            if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
"                return fugitive#head()
"            endif
"        catch
"        endtry
"        return ''
"    endfunction "}}}
"
"    function! MyFileformat() "{{{
"        return winwidth('.') > 70 ? &fileformat : ''
"    endfunction "}}}
"
"    function! MyFiletype() "{{{
"        return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
"    endfunction "}}}
"
"    function! MyFileencoding() "{{{
"        return winwidth('.') > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
"    endfunction "}}}
"
"    function! MyMode() "{{{
"        return winwidth('.') > 60 ? lightline#mode() : ''
"    endfunction "}}}
"
"    call neobundle#untap()
"endif
""}}}

"" accelerated-jk {{{
"if neobundle#tap('accelerated-jk')
"    call neobundle#config({
"        \   'autoload' : {
"        \     'mappings' : [['sxno','<Plug>(accelerated_jk_']],
"        \   }
"        \ })
"    function! neobundle#tapped.hooks.on_source(bundle) "{{{
"        let g:accelerated_jk_acceleration_table=[7,52,57]
"    endfunction "}}}
"    nmap j <Plug>(accelerated_jk_gj)
"    nmap k <Plug>(accelerated_jk_gk)
"endif
""}}}

" mhinz/vim-signify "{{{
if neobundle#tap('vim-signify')
    nmap ]c <plug>(signify-next-hunk)
    nmap [c <plug>(signify-prev-hunk)
    call neobundle#untap()
endif
"}}}

"" Leafcage/yankround {{{
if neobundle#tap('yankround.vim')
    call neobundle#config({
        \   'autoload' : {
        \     'mappings' : ['<Plug>(yankround-'],
        \   }
        \ })
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        " let g:yankround_use_region_hl = 1
    endfunction "}}}
    nmap p <Plug>(yankround-p)
    xmap p <Plug>(yankround-p)
    xmap gp <Plug>(yankround-gp)
    nmap P :Unite yankround<CR>
    "nmap <expr> p yankround#is_active() ?
    "            \ '<Plug>(my-yankround-start)' : '<Plug>(yankround-p)'
    "call submode#enter_with('yankround', 'n', 'r',
    "            \ '<Plug>(my-yankround-start)', '<Plug>(yankround-prev)')
    "call submode#map('yankround', 'n', 'r', 'p', '<Plug>(yankround-prev)')
    "call submode#map('yankround', 'n', 'r', 'n', '<Plug>(yankround-next)')

    call neobundle#untap()
endif
""}}}

" YankRing {{{
" Defines a submode to rapidly choose a register to paste. When entered,
" pastes the default register. Pressing any number will undo the previous
" paste and paste the corresponding kill register. Pressing any letter will
" paste that register in a similar manner.
"
" This is a super lightweight alternative to
" https://github.com/vim-scripts/YankRing.vim and
" https://github.com/maxbrunsfeld/vim-yankstack, which don't seem to play
" nice with heavily customized keymaps since they need to hook into
" D, C, etc.
"
" Requires https://github.com/kana/vim-submode
"
" https://gist.github.com/calmofthestorm/b57f2c7725cd3b159983

"call submode#enter_with('killcycle', 'n', '', ',p', 'p')
"call submode#leave_with('killcycle', 'n', '', '<Esc>')
"call submode#map('killcycle', 'n', '', ']', 'u"0p')
"call submode#map('killcycle', 'n', '', '0', 'u"0p')
"call submode#map('killcycle', 'n', '', '1', 'u"1p')
"call submode#map('killcycle', 'n', '', '2', 'u"2p')
"call submode#map('killcycle', 'n', '', '3', 'u"3p')
"call submode#map('killcycle', 'n', '', '4', 'u"4p')
"call submode#map('killcycle', 'n', '', '5', 'u"5p')
"call submode#map('killcycle', 'n', '', '6', 'u"6p')
"call submode#map('killcycle', 'n', '', '7', 'u"7p')
"call submode#map('killcycle', 'n', '', '8', 'u"8p')
"call submode#map('killcycle', 'n', '', '9', 'u"9p')
"call submode#map('killcycle', 'n', '', 'a', 'u"ap')
"call submode#map('killcycle', 'n', '', 'b', 'u"bp')
"call submode#map('killcycle', 'n', '', 'c', 'u"cp')
"call submode#map('killcycle', 'n', '', 'd', 'u"dp')
"call submode#map('killcycle', 'n', '', 'e', 'u"ep')
"call submode#map('killcycle', 'n', '', 'f', 'u"fp')
"call submode#map('killcycle', 'n', '', 'g', 'u"gp')
"call submode#map('killcycle', 'n', '', 'h', 'u"hp')
"call submode#map('killcycle', 'n', '', 'i', 'u"ip')
"call submode#map('killcycle', 'n', '', 'j', 'u"jp')
"call submode#map('killcycle', 'n', '', 'k', 'u"kp')
"call submode#map('killcycle', 'n', '', 'l', 'u"lp')
"call submode#map('killcycle', 'n', '', 'm', 'u"mp')
"call submode#map('killcycle', 'n', '', 'n', 'u"np')
"call submode#map('killcycle', 'n', '', 'o', 'u"op')
"call submode#map('killcycle', 'n', '', 'p', 'u"pp')
"call submode#map('killcycle', 'n', '', 'q', 'u"qp')
"call submode#map('killcycle', 'n', '', 'r', 'u"rp')
"call submode#map('killcycle', 'n', '', 's', 'u"sp')
"call submode#map('killcycle', 'n', '', 't', 'u"tp')
"call submode#map('killcycle', 'n', '', 'u', 'u"up')
"call submode#map('killcycle', 'n', '', 'v', 'u"vp')
"call submode#map('killcycle', 'n', '', 'w', 'u"wp')
"call submode#map('killcycle', 'n', '', 'x', 'u"xp')
"call submode#map('killcycle', 'n', '', 'y', 'u"yp')
"call submode#map('killcycle', 'n', '', 'z', 'u"zp')
"}

" }}}

" basyura/TweetVim "{{{
" 追加のハイライト {{{
let s:zenkaku_no_highlight_filetypes = []
" 全角スペース
Autocmd ColorScheme * highlight link ZenkakuSpace Error
Autocmd VimEnter,WinEnter * if index(s:zenkaku_no_highlight_filetypes, &filetype) == -1 | syntax match ZenkakuSpace containedin=ALL /　/ | endif
" }}}
"nnoremap <silent><Leader>tw :<C-u>TweetVimUserStream<CR>
"nnoremap <silent><Leader>th :<C-u>TweetVimHomeTimeline<CR>
"nnoremap <silent><Leader>tm :<C-u>TweetVimMentions<CR>
"nnoremap <silent><Leader>ts :<C-u>TweetVimSay<CR>
"nnoremap <silent><Leader>tu :<C-u>TweetVimUserTimeline<Space>
let s:zenkaku_no_highlight_filetypes += ['tweetvim', 'tweetvim_say']

" TweetVim 読み込み時に設定する
let s:bundle = neobundle#get("TweetVim")
function! s:bundle.hooks.on_source(bundle)
    " TweetVim
    if has('gui_running')
        let g:tweetvim_display_icon = 1
    endif
    let g:tweetvim_tweet_per_page = 60
    let g:tweetvim_async_post = 1
    let g:tweetvim_expand_t_co = 1

    command -nargs=1 TweetVimFavorites call tweetvim#timeline('favorites', <q-args>)

    " 行番号いらない
    AutocmdFT tweetvim     setlocal nonumber
    " マッピング
    " 挿入・通常モードで閉じる
    AutocmdFT tweetvim_say nnoremap <buffer><silent><C-g>    :<C-u>q!<CR>
    AutocmdFT tweetvim_say inoremap <buffer><silent><C-g>    <C-o>:<C-u>q!<CR><Esc>
    " ツイート履歴を <C-l> に
    AutocmdFT tweetvim_say inoremap <buffer><silent><C-l>    <C-o>:<C-u>call unite#sources#tweetvim_tweet_history#start()<CR>
    " <Tab> は補完で使う
    AutocmdFT tweetvim_say iunmap   <buffer><Tab>
    " 各種アクション
    AutocmdFT tweetvim     nnoremap <buffer><Leader>s        :<C-u>TweetVimSay<CR>
    AutocmdFT tweetvim     nmap     <buffer>c                <Plug>(tweetvim_action_in_reply_to)
    AutocmdFT tweetvim     nnoremap <buffer>t                :<C-u>Unite tweetvim -no-start-insert -quick-match<CR>
    AutocmdFT tweetvim     nmap     <buffer><Leader>F        <Plug>(tweetvim_action_remove_favorite)
    AutocmdFT tweetvim     nmap     <buffer><Leader>d        <Plug>(tweetvim_action_remove_status)
    " リロード後はカーソルを画面の中央に
    AutocmdFT tweetvim     nmap     <buffer><Tab>            <Plug>(tweetvim_action_reload)
    AutocmdFT tweetvim     nmap     <buffer><silent>gg       gg<Plug>(tweetvim_action_reload)
    " ページ移動を ff/bb から f/b に
    AutocmdFT tweetvim     nmap     <buffer>f                <Plug>(tweetvim_action_page_next)
    AutocmdFT tweetvim     nmap     <buffer>b                <Plug>(tweetvim_action_page_previous)
    " favstar や web UI で表示
    AutocmdFT tweetvim     nnoremap <buffer><Leader><Leader> :<C-u>call <SID>tweetvim_favstar()<CR>
    AutocmdFT tweetvim     nnoremap <buffer><Leader>u        :<C-u>call <SID>tweetvim_open_home()<CR>
    "AutocmdFT tweetvim     nnoremap <buffer><Space><Space>   :<C-u>OpenBrowser https://twitter.com/i/connect<CR>
    " 縦移動
    AutocmdFT tweetvim     nnoremap <buffer><silent>j        :<C-u>call <SID>tweetvim_vertical_move("j")<CR>zz
    AutocmdFT tweetvim     nnoremap <buffer><silent>k        :<C-u>call <SID>tweetvim_vertical_move("k")<CR>zz
    " タイムライン各種
    AutocmdFT tweetvim     nnoremap <silent><buffer>gm       :<C-u>TweetVimMentions<CR>
    AutocmdFT tweetvim     nnoremap <silent><buffer>gh       :<C-u>TweetVimHomeTimeline<CR>
    "AutocmdFT tweetvim     nnoremap <silent><buffer>gu       :<C-u>TweetVimUserTimeline<Space>
    AutocmdFT tweetvim     nnoremap <silent><buffer>gp       :<C-u>TweetVimUserTimeline Linda_pp<CR>
    AutocmdFT tweetvim     nnoremap <silent><buffer>gf       :<C-u>call <SID>open_favstar('')<CR>
    " 不要なマップを除去
    AutocmdFT tweetvim     nunmap   <buffer>ff
    AutocmdFT tweetvim     nunmap   <buffer>bb
    " 自動更新
    AutocmdFT tweetvim     nnoremap <buffer><Leader>au :<C-u>TweetVimAutoUpdate<CR>
    AutocmdFT tweetvim     nnoremap <buffer><Leader>as :<C-u>TweetVimStopAutoUpdate<CR>

    " セパレータを飛ばして移動する
    function! s:tweetvim_vertical_move(cmd)
        execute "normal! ".a:cmd
        let end = line('$')
        while getline('.') =~# '^[-~]\+$' && line('.') != end
            execute "normal! ".a:cmd
        endwhile
        " 一番上/下まで来たら次のページに進む
        let line = line('.')
        if line == end
            call feedkeys("\<Plug>(tweetvim_action_page_next)")
        elseif line == 1
            call feedkeys("\<Plug>(tweetvim_action_page_previous)")
        endif
    endfunction

    function! s:tweetvim_favstar()
        let screen_name = matchstr(getline('.'),'^\s\zs\w\+')
        let route = empty(screen_name) ? 'me' : 'users/'.screen_name

        execute "OpenBrowser http://ja.favstar.fm/".route
    endfunction

    function! s:open_favstar(user)
        if empty(a:user)
            OpenBrowser http://ja.favstar.fm/me
        else
            execute "OpenBrowser http://ja.favstar.fm/users/" . a:user
        endif
    endfunction
    command! OpenFavstar call <SID>open_favstar(expand('<cword>'))

    function! s:tweetvim_open_home()
        let username = expand('<cword>')
        if username =~# '^[a-zA-Z0-9_]\+$'
            execute "OpenBrowser https://twitter.com/" . username
        endif
    endfunction

    " 自動更新 {{{
    let s:tweetvim_update_interval_seconds = 60
    let s:tweetvim_timestamp = localtime()
    function! s:tweetvim_autoupdate()
        let current = localtime()
        if current - s:tweetvim_timestamp > s:tweetvim_update_interval_seconds
            call feedkeys("\<Plug>(tweetvim_action_reload)")
            let s:tweetvim_timestamp = current
        endif
        call feedkeys(mode() ==# 'i' ? "\<C-g>\<Esc>" : "g\<Esc>", 'n')
    endfunction

    function! s:tweetvim_setup_autoupdate()
        augroup vimrc-tweetvim-autoupdate
            autocmd!
            autocmd CursorHold * call <SID>tweetvim_autoupdate()
        augroup END
    endfunction
    command! -nargs=0 TweetVimAutoUpdate call <SID>tweetvim_setup_autoupdate()
    command! -nargs=0 TweetVimStopAutoUpdate autocmd! vimrc-tweetvim-autoupdate
    "}}}

    if filereadable($HOME.'/.tweetvimrc')
        source $HOME/.tweetvimrc
    endif

endfunction
unlet s:bundle
"}}}

" thinca/vim-scouter {{{
if neobundle#tap('vim-scouter')
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : [
        \       'Scouter'
        \     ],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}

" thinca/vim-visualstar {{{
if neobundle#tap('vim-visualstar')
    call neobundle#config({
        \   'autoload' : {
        \     'mappings' : ['<Plug>(visualstar-'],
        \   }
        \ })
    vmap <silent>*  <Plug>(visualstar-*);n
    call neobundle#untap()
endif
"}}}

" tyru/caw.vim {{{
if neobundle#tap('caw.vim')
    call neobundle#config({
        \   'autoload' : {
        \     'mappings' : ['<Plug>(caw:'],
        \   }
        \ })
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        let g:caw_no_default_keymappings = 1
    endfunction "}}}
    " Beggining of Line Comment Toggle
    nmap <Leader>cc <Plug>(caw:i:toggle)
    vmap <Leader>cc <Plug>(caw:i:toggle)
    nmap <Leader>ci <Plug>(caw:i:toggle)
    vmap <Leader>ci <Plug>(caw:i:toggle)

    " End of Line Comment Toggle
    nmap <Leader>ca <Plug>(caw:a:toggle)
    vmap <Leader>ca <Plug>(caw:a:toggle)

    " Block Comment Toggle
    nmap <Leader>cw <Plug>(caw:wrap:toggle)
    vmap <Leader>cw <Plug>(caw:wrap:toggle)

    " Break line and Comment
    nmap <Leader>co <Plug>(caw:jump:comment-next)
    nmap <Leader>cO <Plug>(caw:jump:comment-prev)
    call neobundle#untap()
endif
"}}}

" vim-scripts/loremipsum {{{
if neobundle#tap('loremipsum')
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : [
        \       'Loremipsum'
        \     ],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}

" Shougo/junkfile.vim {{{
if neobundle#tap('junkfile.vim')
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : 'JunkfileOpen',
        \     'unite_sources' : ['junkfile', 'junkfile/new'],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}

" thinca/vim-prettyprint {{{
if neobundle#tap('vim-prettyprint')
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : 'PP',
        \     'functions' : 'PP',
        \   }
        \ })
    call neobundle#untap()
endif
"}}}

" rbtnn/puyo.vim {{{
if neobundle#tap('puyo.vim')
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : [
        \       'Puyo', 'PuyoTeto'
        \     ],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}

" h1mesuke/vim-alignta {{{
if neobundle#tap('vim-alignta')
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : [
        \       'Alignta',
        \     ],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}

" vim-submode {{{
if neobundle#tap('vim-submode')
    call neobundle#config({})

    function! neobundle#tapped.hooks.on_source(bundle)
        let g:submode_keep_leaving_key = 1
    endfunction

    " Resize window
    "call submode#enter_with('winsize', 'n', '', '<C-w>>', '<C-w>>')
    "call submode#enter_with('winsize', 'n', '', '<C-w><', '<C-w><')
    "call submode#enter_with('winsize', 'n', '', '<C-w>+', '<C-w>+')
    "call submode#enter_with('winsize', 'n', '', '<C-w>-', '<C-w>-')
    "call submode#map('winsize', 'n', '', '>', '<C-w>3>')
    "call submode#map('winsize', 'n', '', '<', '<C-w>3<')
    "call submode#map('winsize', 'n', '', '+', '<C-w>3+')
    "call submode#map('winsize', 'n', '', '-', '<C-w>3-')

    "function! s:my_x()
    "    undojoin
    "    normal! "_x
    "endfunction
    "nnoremap <silent> <Plug>(my-x) :<C-u>call <SID>my_x()<CR>
    "call submode#enter_with('my_x', 'n', '', 'x', '"_x')
    "call submode#map('my_x', 'n', 'r', 'x', '<Plug>(my-x)')
    call neobundle#untap()
endif
" }}}

" vim-niceblock {{{
if neobundle#tap('vim-niceblock')
    call neobundle#config({
        \   'autoload' : {
        \     'mappings' : [
        \       '<Plug>(niceblock-',
        \     ],
        \   }
        \ })
    " Improved visual selection.
    xmap I  <Plug>(niceblock-I)
    xmap A  <Plug>(niceblock-A)
    vnoremap <expr> <Plug>(niceblock-r) niceblock#force_blockwise('r')
    xmap r <Plug>(niceblock-r)

    call neobundle#untap()
endif
" }}}

" vim-rengbang {{{
if neobundle#tap('vim-rengbang')
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : [
        \       'RengBang',
        \     ],
        \   }
        \ })
    " TODO:
    " Count Up Function {{{
    " nnoremap <silent> <Leader>co :ContinuousNumber <C-a><CR>
    vnoremap <silent> <Leader>co :ContinuousNumber <C-a><CR>
    command! -count -nargs=1 ContinuousNumber let s:c = col('.')|for s:n in range(1, <count>?<count>-line('.'):1)|exec 'normal! j' . s:n . <q-args>|call cursor('.', s:c)|endfor
    "}}}

    call neobundle#untap()
endif
" }}}

" tpope/vim-fugutive {{{
if neobundle#tap('vim-fugitive')
    " Config {{{
    call neobundle#config({
        \ 'autoload' : {
        \   'commands' : [
        \     'Gstatus', 'Gcommit', 'Gwrite', 'Gdiff', 'Gblame', 'Git', 'Ggrep'
        \   ]
        \   }
        \ })
    " }}}

    let s:bundle = neobundle#get('vim-fugitive')
    function! s:bundle.hooks.on_post_source(bundle)
        doautoall fugitive BufNewFile
    endfunction
    " Setting {{{
    nnoremap ;gs :<C-u>Gstatus<CR>
    nnoremap ;gc :<C-u>Gcommit -v<CR>
    nnoremap ;ga :<C-u>Gwrite<CR>
    nnoremap ;gd :<C-u>Gdiff<CR>
    nnoremap ;gb :<C-u>Gblame<CR>
    "}}}
    call neobundle#untap()
endif
" }}}

" vim-scripts/CSS-one-line--multi-line-folding {{{
if neobundle#tap('CSS-one-line--multi-line-folding')
    call neobundle#config({
        \ "autoload": {
        \   "filetypes": ["css"],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}

" heavenshell/vim-pydocstring {{{
if neobundle#tap('vim-pydocstring')
    call neobundle#config({
        \ "autoload": {
        \   "filetypes": ["python", "python3", "djangohtml"],
        \   }
        \ })
    call neobundle#untap()
endif
"}}}

" tell-k/vim-autopep8 {{{
if neobundle#tap('vim-autopep8')
    call neobundle#config({
        \ "autoload": {
        \   "filetypes": ["python", "python3", "djangohtml"],
        \   "commands": ["Autopep8"],
        \   }
        \ })
    call neobundle#untap()
    let g:no_autopep8_maps = 1
    command! -bar Autopep8 call Autopep8()
endif
" }}}

" hynek/vim-python-pep8-indent {{{
if neobundle#tap('vim-python-pep8-indent')
    " Config {{{
    call neobundle#config({
        \   'autoload' : {
        \     'filetypes' : [ 'python'],
        \   }
        \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" tmhedberg/SimpylFold {{{
if neobundle#tap('SimpylFold')
    call neobundle#config({
        \ "autoload": {
        \   "filetypes": ["python", "python3", "djangohtml"],
        \   }
        \ })
    function! neobundle#tapped.hooks.on_source(bundle)
        let g:SimpylFold_docstring_preview = 1
    endfunction
    call neobundle#untap()
endif
"}}}

" basyura/J6uil.vim {{{
if neobundle#tap('J6uil.vim')
    " Config {{{
    call neobundle#config({
        \   'depends': ['Shougo/vimproc', 'mattn/webapi-vim'],
        \   'autoload' : {
        \     'commands' : [ 'J6uil' ],
        \     'unite_sources' : [ 'J6uil/members', 'J6uil/rooms' ],
        \   }
        \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        let g:J6uil_empty_separator = 1
        AutocmdFT J6uil call s:J6uil_settings()
        function! s:J6uil_settings()
            nunmap <buffer> s
            setlocal colorcolumn=0
            nmap <buffer> <Leader>s <Plug>(J6uil_open_say_buffer)
        endfunction
    endfunction "}}}
    call neobundle#untap()
endif
" }}}

" t9md/vim-quickhl {{{
if neobundle#tap('vim-quickhl')
    " Config {{{
    call neobundle#config({
        \   'autoload' : {
        \     'mappings' : [ '<Plug>(quickhl-manual-' ],
        \   }
        \ })
    " }}}
    " Setting {{{
    nmap ;m <Plug>(quickhl-manual-this)
    vmap ;m <Plug>(quickhl-manual-this)
    nmap ;M <Plug>(quickhl-manual-reset)
    vmap ;M <Plug>(quickhl-manual-reset)
    "}}}
    call neobundle#untap()
endif
" }}}

" tyru/capture.vim {{{
if neobundle#tap('capture.vim')
    " Config {{{
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : [ 'Capture' ],
        \   }
        \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" rhysd/unite-codic.vim {{{
if neobundle#tap('unite-codic.vim')
    " Config {{{
    call neobundle#config({
        \   'depends': ['koron/codic-vim'],
        \   'autoload' : {
        \     'unite_sources' : [
        \       'codic',
        \     ],
        \   }
        \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" itchyny/calendar.vim {{{
if neobundle#tap('calendar.vim')
    " Config {{{
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : [
        \       'Calendar',
        \     ],
        \   }
        \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        let g:calendar_google_calendar = 1
        let g:calendar_google_task = 1
        let g:calendar_date_endian = 'big'

        AutocmdFT calendar call s:init_calendar()
        function! s:init_calendar() "{{{
            nmap <buffer>l <Plug>(calendar_next)
            nmap <buffer>h <Plug>(calendar_prev)
            nmap <buffer>e <Plug>(calendar_event)
            highlight clear TrailingSpaces
        endfunction "}}}
    endfunction "}}}
    call neobundle#untap()
endif
" }}}

" osyo-manga/vim-watchdogs {{{
if neobundle#tap('vim-watchdogs')
    " Config {{{
    call neobundle#config({
                \   'depends' : [
                \       'thinca/vim-quickrun',
                \       'Shougo/vimproc',
                \       'osyo-manga/shabadou.vim',
                \       'jceb/vim-hier',
                \       'dannyob/quickfixstatus',
                \   ],
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        let g:watchdogs_check_BufWritePost_enable = 1
        let g:watchdogs_check_CursorHold_enable = 1
        let g:watchdogs_check_BufWritePost_enables = {
        \   "scala" : 0
        \}
        let g:watchdogs_check_CursorHold_enables = {
        \   "scala" : 0
        \}
        call watchdogs#setup(g:quickrun_config)
    endfunction "}}}
    augroup source-watchdogs
        autocmd!
        autocmd BufWritePre * NeoBundleSource vim-watchdogs
        \       autocmd! source-watchdogs *
    augroup END
    call neobundle#untap()
endif
" }}}

" kana/vim-vspec {{{
if neobundle#tap('vim-vspec')
    Autocmd BufRead,BufNew,BufNewFile *_spec.vim NeoBundleSource vim-vspec
    call neobundle#untap()
endif
" }}}

" osyo-manga/vim-over {{{
if neobundle#tap('vim-over')
    " Config {{{
    call neobundle#config({
        \   'autoload' : {
        \     'commands' : [
        \       'OverCommandLine',
        \     ],
        \   }
        \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" vim-jp/vital.vim {{{
if neobundle#tap('vital.vim')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'commands' : ['Vitalize'],
                \     'functions' : ['vital#of', 'vital'],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" tyru/restart.vim {{{
if neobundle#tap('restart.vim')
    " Config {{{
    call neobundle#config({
        \   'gui' : 1,
        \   'autoload' : {
        \     'commands' : 'Restart'
        \   }
        \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" thinca/vim-editvar {{{
if neobundle#tap('vim-editvar')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'commands' : [
                \       'Editvar',
                \     ],
                \     'unite_sources' : [
                \       'variable'
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" thinca/vim-threes {{{
if neobundle#tap('vim-threes')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'commands' : [
                \       'ThreesStart',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" welle/targets.vim {{{
if neobundle#tap('targets.vim')
    " Disable `n` , `l` , `A`
    let g:targets_aiAI = 'ai I'
    let g:targets_nlNL = '  NL'
    call neobundle#untap()
endif
" }}}

" kannokanno/previm {{{
if neobundle#tap('previm')
    " Config {{{
    call neobundle#config({
                \   'depends': ['tyru/open-browser.vim'],
                \   'autoload' : {
                \     'filetypes' : [
                \       'markdown',
                \     ],
                \     'commands' : [
                \       'PrevimOpen',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" marijnh/tern_for_vim {{{
if neobundle#tap('tern_for_vim')
    " Config {{{
    call neobundle#config({
                \   'build' : {
                \     'others' : 'npm install'
                \   },
                \   'autoload' : {
                \       'functions' : ['tern#Complete', 'tern#Enable'],
                \       'filetypes' : ['javascript']
                \     },
                \   'commands' : ['TernDef', 'TernDoc', 'TernType',
                \                 'TernRefs', 'TernRename'],
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" maksimr/vim-jsbeautify {{{
if neobundle#tap('vim-jsbeautify')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'filetypes' : [
                \       'javascript',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" derekwyatt/vim-scala {{{
if neobundle#tap('vim-scala')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'filetypes' : [
                \       'scala',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" derekwyatt/vim-sbt {{{
if neobundle#tap('vim-sbt')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'filetypes' : [
                \       'sbt',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" mdreves/vim-scaladoc {{{
if neobundle#tap('vim-scaladoc')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'filetypes' : [
                \       'scala',
                \     ],
                \   }
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        AutocmdFT scala nnoremap <buffer> K :<C-u>call scaladoc#Search(expand("<cword>"))<CR>
    endfunction "}}}
    call neobundle#untap()
endif
" }}}

" gre/play2vim {{{
if neobundle#tap('play2vim')
    " Config {{{
    call neobundle#config({
                \   'depends' : 'derekwyatt/vim-scala',
                \   'autoload' : {
                \     'filetypes' : [
                \       'scala', 'play2-html', 'play2-conf', 'play2-routes'
                \     ],
                \   }
                \ })
    " }}}
    Autocmd BufRead,BufNewFile *.scala.html set filetype=html syntax=play2-html
    Autocmd BufRead,BufNewFile */conf/\(*\|\)routes set filetype=play2-routes
    Autocmd BufRead,BufNewFile */conf/*.conf setf play2-conf
    Autocmd BufRead,BufNewFile plugins.sbt set filetype=scala
    call neobundle#untap()
endif
" }}}

" plasticboy/vim-markdown {{{
if neobundle#tap('vim-markdown')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'filetypes' : [
                \       'markdown',
                \     ],
                \   }
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        let g:markdown_no_default_key_mappings = 1
        AutocmdFT markdown nmap <buffer> ]] <Plug>(Markdown_MoveToNextHeader)
        AutocmdFT markdown nmap <buffer> [[ <Plug>(Markdown_MoveToPreviousHeader)
    endfunction "}}}
    call neobundle#untap()
endif
" }}}

" vim-jp/autofmt {{{
if neobundle#tap('autofmt')
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        set formatexpr=autofmt#compat#formatexpr()
    endfunction "}}}
    call neobundle#untap()
endif
" }}}

" ujihisa/neco-look {{{
if neobundle#tap('neco-look')
    " Config {{{
    call neobundle#config({
                \   'depends' : 'Shougo/neocomplete.vim',
                \   'disabled': !executable('look'),
                \   'autoload' : {
                \     'filetypes' : [
                \       'markdown',
                \       'gitcommit',
                \     ],
                \   }
                \ })
    " }}}
    AutocmdFT gitcommit NeoBundleSource neco-look
    function! neobundle#tapped.hooks.on_post_source(bundle)
        "only show 5 candidates
        call neocomplete#custom#source('look', 'max_candidates', 5)
    endfunction
    call neobundle#untap()
endif
" }}}

" mkomitee/vim-gf-python {{{
if neobundle#tap('vim-gf-python')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'filetypes' : [
                \       'python',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

"" osyo-manga/vim-precious {{{
"if neobundle#tap('vim-precious')
"    " Config {{{
"    call neobundle#config({
"                \   'depends' : [
"                \       'Shougo/context_filetype.vim',
"                \       'kana/vim-textobj-user'
"                \   ],
"                \   'autoload' : {
"                \     'filetypes' : [
"                \       'markdown',
"                \     ],
"                \     'commands' : [
"                \       'PreciousSwitch', 'PreciousReset'
"                \     ]
"                \   }
"                \ })
"    " }}}
"    " precious quickrun
"    AutocmdFT markdown nmap <buffer> ;pqr <Plug>(precious-quickrun-op)
"    AutocmdFT markdown omap <buffer> q <Plug>(textobj-precious-i)
"
"    let g:precious_enable_switchers = {
"    \   "*" : {
"    \       "setfiletype" : 0
"    \   },
"    \   "markdown" : {
"    \       "setfiletype" : 1
"    \   },
"    \}
"
"    let g:precious_enable_switch_CursorMoved = {
"    \   "*" : 0
"    \}
"    let g:precious_enable_switch_CursorMoved_i = {
"    \   "*" : 0
"    \}
"
"    augroup precious_insert
"        autocmd!
"        autocmd InsertEnter * :PreciousSwitch
"        autocmd InsertLeave * :PreciousReset
"    augroup END
"
"    call neobundle#untap()
"endif
"" }}}

" itchyny/screensaver.vim {{{
if neobundle#tap('screensaver.vim')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'commands' : [
                \       'ScreenSaver',
                \     ],
                \   }
                \ })
    " }}}
    AutocmdFT screensaver setlocal colorcolumn=0
    call neobundle#untap()
endif
" }}}

" thinca/vim-qfreplace {{{
if neobundle#tap('vim-qfreplace')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'filetypes' : [ 'unite', 'quickfix'],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" haya14busa/unite-ghq {{{
if neobundle#tap('unite-ghq')
    call neobundle#config({
                \   'autoload' : {
                \     'unite_sources' : [
                \       'ghq',
                \     ],
                \   }
                \ })
    nnoremap go :<C-u>Unite ghq<CR>
    call neobundle#untap()
endif
" }}}

" rhysd/committia {{{
if neobundle#tap('committia.vim')
    let g:committia_min_window_width = '140'
    let g:committia_hooks = {}
    function! g:committia_hooks.edit_open(info)
        setlocal spell
        " If no commit message, start with insert mode
        if getline(1) ==# ''
            startinsert
        end
        "imap <buffer><C-j> <Plug>(committia-scroll-diff-down-half)
        "imap <buffer><C-k> <Plug>(committia-scroll-diff-up-half)
    endfunction
    call neobundle#untap()
endif
" }}}

" haya14busa/endtagcomment.vim {{{
if neobundle#tap('endtagcomment.vim')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'mappings' : ['<Plug>(endtagcomment)'],
                \   }
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        let g:endtagcommentFormat = '<!-- /{%tag_name}{%id}{%class} -->'
    endfunction "}}}
    nmap ,t <Plug>(endtagcomment)
    call neobundle#untap()
endif
" }}}

" rhysd/unite-zsh-cdr.vim {{{
if neobundle#tap('unite-zsh-cdr.vim')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'unite_sources' : [
                \       'unite-zsh-cdr.vim',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" haya14busa/unite-reading-vimrc {{{
if neobundle#tap('unite-reading-vimrc')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'unite_sources' : [
                \       'reading-vimrc',
                \     ],
                \   }
                \ })
    " }}}
    call neobundle#untap()
endif
" }}}

" Leafcage/foldCC {{{
if neobundle#tap('foldCC')
    call neobundle#config({})
    set foldmethod=marker
    set foldtext=foldCC#foldtext()
    set foldcolumn=0
    set fillchars=vert:\|
    noremap [fold]g :<C-u>echo foldCC#navi()<CR>
    call neobundle#untap()
endif " }}}

" haya14busa/unite-historia {{{
if neobundle#tap('unite-historia')
    " Config {{{
    call neobundle#config({
                \   'depends' : ['Shougo/unite.vim'],
                \   'autoload' : {
                \     'unite_sources' : [
                \       'historia/', 'historia/new'
                \     ],
                \   }
                \ })
    " }}}
    nnoremap <silent> ;<C-r> :<C-u>Unite historia/new historia/command
                \   -direction=botright
                \   -hide-source-names<CR>
    call neobundle#untap()
endif
" }}}

" osyo-manga/vim-brightest {{{
if neobundle#tap('vim-brightest')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'commands' : ['BrightestEnable'],
                \   }
                \ })
    " }}}

    augroup load_brightest
        autocmd!
        autocmd CursorMoved * NeoBundleSource vim-brightest
        autocmd CursorMoved * autocmd! load_brightest *
    augroup END

    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        let g:brightest#highlight = {
        \   "group" : "BrightestUnderline",
        \   "priority" : -1
        \}
        let g:brightest#pattern = '\w\+'
    endfunction "}}}

    call neobundle#untap()
endif
" }}}

" mattn/disableitalic-vim {{{
if neobundle#tap('disableitalic-vim')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'commands' : [
                \       'DisableItalic',
                \     ],
                \   }
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        " TODO: autocmd for Colorscheme if it's gVim
    endfunction "}}}
    call neobundle#untap()
endif
" }}}

" rhysd/vim-grammarous {{{
if neobundle#tap('vim-grammarous')
    " Config {{{
    call neobundle#config({
                \   'autoload' : {
                \     'commands' : [
                \       'GrammarousCheck',
                \     ],
                \     'mappings' : [
                \       '<Plug>',
                \     ],
                \   }
                \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        let g:grammarous#enable_spell_check = 1
    endfunction "}}}
    call neobundle#untap()
endif
" }}}

"" haya14busa/incsearch.vim {{{
"if neobundle#tap('incsearch.vim')
"    " Config {{{
"    call neobundle#config({
"                \   'autoload' : {
"                \     'mappings' : [
"                \       '<Plug>(incsearch-',
"                \     ],
"                \   }
"                \ })
"    " }}}
"    function! NormalZZ()
"        try
"            normal! zz
"        catch /E523:/
"        endtry
"        let h = winheight(0)
"        call winrestview({'topline': line('.') - h / 2})
"    endfunction
"    function! neobundle#tapped.hooks.on_post_source(bundle) "{{{
"        " IncSearchNoreMap <Tab> <Over>(incsearch-next)
"        " IncSearchNoreMap <S-Tab> <Over>(incsearch-prev)
"        " IncSearchNoreMap <C-l> <Over>(buffer-complete)
"        augroup incsearch
"            autocmd!
"            autocmd User IncSearchEnter BrightestDisable
"            autocmd User IncSearchLeave BrightestEnable
"            " autocmd User IncSearchExecute echom 'exit'
"            " autocmd User IncSearchExecutePre echom 'exit'
"            " autocmd User IncSearchChar call Plog("called on char")
"            " autocmd User IncSearchChar call NormalZZ()
"        augroup END
"    endfunction "}}}
"    function! neobundle#tapped.hooks.on_source(bundle) "{{{
"    endfunction "}}}
"    " Setting {{{
"    " let g:incsearch#emacs_like_keymap = 1
"    " let g:incsearch#highlight = {
"    " \   'match' : {
"    " \       'group' : 'IncSearchUnderline'
"    " \   }
"    " \ }
"    map / <Plug>(incsearch-forward)
"    map ? <Plug>(incsearch-backward)
"    map g/ <Plug>(incsearch-stay)
"    highlight IncSearchCursor ctermfg=0 ctermbg=9 guifg=#000000 guibg=#FF0000
"    " highlight IncSearchOnCursor term=reverse ctermbg=236 guibg=#232526
"    " Autocmd VimEnter IncSearchNoreMap <Tab> <Over>(incsearch-next)
"
"    set hlsearch | nohlsearch
"    let g:incsearch#auto_nohlsearch = 1
"    let g:incsearch#consistent_n_direction = 1
"    let g:incsearch#do_not_save_error_message_history = 1
"    map  n <Plug>(incsearch-nohl)<Plug>(anzu-n-with-echo)
"    map  N <Plug>(incsearch-nohl)<Plug>(anzu-N-with-echo)
"    map  n <Plug>(incsearch-nohl-n)
"    map  N <Plug>(incsearch-nohl-N)
"    nmap  n <Plug>(incsearch-nohl)<Plug>(anzu-n-with-echo)
"    nmap  N <Plug>(incsearch-nohl)<Plug>(anzu-N-with-echo)
"    " map <silent> n <Plug>(incsearch-nohl)<Plug>(anzu-n)
"    " map <silent> N <Plug>(incsearch-nohl)<Plug>(anzu-N)
"    " TODO: work with nohl
"    vmap * <Plug>(visualstar-*)
"    map  * <Plug>(anzu-star-with-echo)<Plug>(incsearch-nohl)N
"    map g* <Plug>(incsearch-nohl-g*)
"
"    "}}}
"    call neobundle#untap()
"endif
"" }}}
"

" End plugins }}}

" Misc {{{=========================
" " sticky_table {{{
" let sticky_table_us = {
"       \',' : '<', '.' : '>', '/' : '?',
"       \'1' : '!', '2' : '@', '3' : '#', '4' : '$', '5' : '%',
"       \'6' : '^', '7' : '&', '8' : '*', '9' : '(', '0' : ')', '-' : '_', '=' : '+',
"       \';' : ':', '[' : '{', ']' : '}', '`' : '~', "'" : "\"", '\' : '|',
"       \}
"
" let sticky_table_ja = {
"       \',' : '<', '.' : '>', '/' : '?',
"       \'1' : '!', '2' : '"', '3' : '#', '4' : '$', '5' : '%',
"       \'6' : '&', '7' : "'", '8' : '(', '9' : ')', '0' : '_', '-' : '=', '^' : '~',
"       \';' : '+', ':' : '*', '[' : '{', ']' : '}', '@' : '`', '\' : '|'
"       \}
" "}}}

function! Plog(msg) "{{{
    try
        call vimproc#system('echo "' . strtrans(PP(a:msg)) . '" >> ~/vim.log')
    catch
        call vimproc#system("echo '" . strtrans(a:msg) . "' >> ~/vim.log")
    endtry
    " call Plog(' kokomade OK')
    " tail -f ~/vim.log
endfunction "}}}


command! -bar TimerStart let start_time = reltime()
command! -bar TimerEnd echo reltimestr(reltime(start_time)) | unlet start_time

" Color column
if v:version >= 703
    " For conceal.
    set conceallevel=2 concealcursor=iv
    set colorcolumn=79
endif

let g:loaded_netrwPlugin=1

function! s:open_help_en_jp(args)
    let en = a:args . '@en'
    let ja = a:args . '@ja'
    exec "tab help " . en
    setlocal scrollbind
    split
    exec "help " . ja
    setlocal scrollbind
endfunction
command! -nargs=1 -complete=help Help call <SID>open_help_en_jp("<args>")


" Ref: https://github.com/rhysd/dotfiles/blob/master/vimrc
" Execute a:cmd at first, and rotate cursor within line
let s:smart_line_pos = -1
function! s:smart_move(cmd) "{{{
    let line = line('.')
    if s:smart_line_pos == line . a:cmd
        call <SID>rotate_in_line()
    else
        execute "normal! " . a:cmd
        " Store previous line number and mapping
        let s:smart_line_pos = line . a:cmd
    endif
endfunction "}}}
function! s:rotate_in_line() "{{{
    let c = virtcol('.')

    let cmd = c == 1 ? 'g^' : 'g$'
    execute "normal! ".cmd

    " If there is no space at beginning of line, toggle bol & eol
    if c == virtcol('.')
        if cmd == 'g^'
            normal! g$
        else
            normal! g0
        endif
    endif
endfunction "}}}
" Toggle 0, ^, $
" nnoremap <silent> 0 :<C-u>call <SID>smart_move('g0')<CR>

" Backspace: Act like normal backspace
noremap <BS>  "_X

function! s:my_HL(motion) "{{{
    let current_line = line('.')
    let flag_line = a:motion == 'H' ? line('w0') : line('w$')
    if current_line == flag_line && v:count == 0
        " let middle_line = (line('w$') - line('w0')) / 2 + line('w0')
        let middle_line = (line('w$') - line('w0') + 1) / 4 + 1
        exec "normal! " . middle_line . a:motion
    else
        exec "normal! " . v:count . a:motion
    endif
endfunction "}}}
nnoremap <silent> L :call <SID>my_HL('L')<CR>
nnoremap <silent> H :call <SID>my_HL('H')<CR>

function! s:my_gm()
    let current_line = {}
    let current_line.num = line('.')
    function! current_line.getline()
        return getline(self.num)
    endfunction
    let current_line.len = strlen(current_line.getline())
    let current_line.disp_len = strdisplaywidth(current_line.getline())
    call cursor(current_line.num, current_line.len / 2)
endfunction
nnoremap <silent> gm :<C-u>call <SID>my_gm()<CR>

command! -nargs=0 GetHighlightingGroup
            \ echom 'hi<' . synIDattr(synID(line('.'),col('.'),1),'name') . '>trans<'
            \ . synIDattr(synID(line('.'),col('.'),0),'name') . '>lo<'
            \ . synIDattr(synIDtrans(synID(line('.'),col('.'),1)),'name') . '>'

" Rename file
" http://vim-users.jp/2009/05/hack17/
command! -nargs=1 -complete=file Rename f <args>|call delete(expand('#'))

" Change current directory.
" http://vim-users.jp/2009/09/hack69/
command! -nargs=? -complete=dir -bang CD  call s:ChangeCurrentDir('<args>', '<bang>')
function! s:ChangeCurrentDir(directory, bang) "{{{
    if a:directory == ''
        lcd %:p:h
    else
        execute 'lcd' . a:directory
    endif

    if a:bang == ''
        pwd
    endif
endfunction "}}}

" nmap <expr> f v:count > 0 ? 'f' : '<Plug>(easymotion-fl)'
" set wildignore=*.tmp,*.swp,*.bak,*.class,*.pyc,*.o,*.exe,*.dll,*.so " ignore some files when auto-completing file names
" hi link EasyMotionMoveHL Search

" SplitAndGo {{{
command! -count=1 -nargs=1 -complete=customlist,SAG_Complete SplitAndGo call SplitAndGo(<q-args>)

function! SplitAndGo(cmd)
  let cnt = v:count
  let cmd = a:cmd ==# 'split' ? 'topleft ' . a:cmd : 'botright ' . a:cmd

  execute cmd
  if cnt > 0
    execute "normal! " . cnt . 'G'
  endif
endfunction

function! SAG_Complete()
  return ['split', 'vsplit']
endfunction

nnoremap _ :SplitAndGo split<CR>
nnoremap <bar> :SplitAndGo vsplit<CR>

function! s:norelativenumber()
    augroup restore_op
        autocmd!
        autocmd CursorMoved * setlocal norelativenumber
        autocmd CursorMoved * augroup restore_op | execute "autocmd!" | execute "augroup END"
        autocmd CursorHold * setlocal norelativenumber
        autocmd CursorHold * augroup restore_op | execute "autocmd!" | execute "augroup END"
    augroup END
    return ""
endfunction

function! s:ToggleRelativeNumber()
    if &relativenumber
        set norelativenumber
        let &number = exists("b:togglernu_number") ? b:togglernu_number : 1
    else
        let b:togglernu_number = &number
        set relativenumber
    endif
    redraw! " these two lines required for omap

    return ''
endfunction

nnoremap <silent> <Leader>m :call <SID>ToggleRelativeNumber()<CR>
" vnoremap <silent> m :<C-U>call <SID>ToggleRelativeNumber()<CR>gv
onoremap <expr> m <SID>ToggleRelativeNumber() . <SID>norelativenumber()

"}}}

command! Date :call setline('.', getline('.') . strftime('%Y/%m/%d (%a) %H:%M'))

Autocmd ColorScheme hi! default link MatchParen Title
hi! default link MatchParen Title

" file encoding & line feed code {{{
command! -bang -bar -complete=file -nargs=? Utf8
\   edit<bang> ++enc=utf-8 <args>
command! -bang -bar -complete=file -nargs=? Iso2022jp
\   edit<bang> ++enc=iso-2022-jp <args>
command! -bang -bar -complete=file -nargs=? Cp932
\   edit<bang> ++enc=cp932 <args>
command! -bang -bar -complete=file -nargs=? Euc
\   edit<bang> ++enc=euc-jp <args>
command! -bang -bar -complete=file -nargs=? Utf16
\   edit<bang> ++enc=utf-16le <args>
command! -bang -bar -complete=file -nargs=? Utf16be
\   edit<bang> ++enc=utf-16 <args>
command! -bang -bar -complete=file -nargs=? Unix
\   edit<bang> ++fileformat=unix <args>
command! -bang -bar -complete=file -nargs=? Mac
\   edit<bang> ++fileformat=mac <args>
command! -bang -bar -complete=file -nargs=? Dos
\   edit<bang> ++fileformat=dos <args>
" }}}

" format JSON
command! -range FormatJson <line1>,<line2>!python -m json.tool

command! -bang -nargs=* PluginTest call PluginTest(<bang>0, <q-args>)
function! PluginTest(is_gui, extraCommand)
    let cmd = a:is_gui ? 'gvim' : 'vim'
    let vimrc_path = $HOME . '/.vimrc.min'
    let vimrc = filereadable(vimrc_path) ? vimrc_path : 'NONE'
    let extraCommand = empty(a:extraCommand) ? '' : ' -c "au VimEnter * ' . a:extraCommand . '"'
    silent! execute printf('!%s -u %s -N --cmd "set rtp+=%s" %s'
    \   , cmd, vimrc, getcwd(), extraCommand)
    redraw!
endfunction

"nnoremap <C-j> <C-f>nzzzv
"nnoremap <C-k> <C-b>Nzzzv


" NOTE:
"  nnoremap <buffer><nowait> ; ;
"
"}}}

" Finally {{{ ======================
"" Installation check.
"NeoBundleCheck
"if !has('vim_starting')
"    call neobundle#call_hook('on_source')
"endif
"set secure
""}}}

" Origin {{{

" os : archlinux
" terminal : lilyterm
" font : ttf-dejavu
" shell : zsh
" editor : vim
" virtual : tmux
" source : https://github.com/syui/dotfiles

set modelines=3
set noimdisable
set iminsert=0 imsearch=0
set noimcmdline
set ignorecase
set virtualedit+=block
"set clipboard=unnamedplus,unnamed
"set uncommand=clipboard
set clipboard=unnamedplus 
set clipboard=unnamed,autoselect

let mapleader = ","

map <F4> <ESC>:bp<CR>
map <F5> <ESC>:bn<CR>
" map <F6> <ESC>:bnext \| bdelete #<CR>
nmap y9 y$
nmap y0 y^
nmap ye ;let @"=expand("<cword>")<CR>

nnoremap Q :q!<CR>
nnoremap vy vawy
vnoremap v $h
vnoremap < <gv
vnoremap > >gv
nnoremap gb '[
nnoremap gp ']

"inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>
command! Bw :bnext \| bdelete #
vnoremap p <Esc>;let current_reg = @"<CR>gvdi<C-R>=current_reg<CR><Esc>

" c
nnoremap <silent> ciy ciw<C-r>0<ESC>:let@/=@1<CR>:noh<CR>
nnoremap <silent> cy   ciW<C-r>0<ESC>:let@/=@1<CR>:noh<CR>
vnoremap <silent> cy   c<C-r>0<ESC>:let@/=@1<CR>:noh<CR>

" edition cursor
augroup edition-cursor
    autocmd!
    autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g`\"" | endif
augroup END

" comment
augroup comment-outer
        autocmd!
        autocmd FileType * setlocal formatoptions-=ro
augroup END

" number
nnoremap <silent> co :ContinuousNumber <C-a><CR>
vnoremap <silent> co :ContinuousNumber <C-a><CR>
command! -count -nargs=1 ContinuousNumber let c = col('.')|for n in range(1, <count>?<count>-line('.'):1)|exec 'normal! j' . n . <q-args>|call cursor('.', c)|endfor

" powerline
set laststatus=2
let g:Powerline_symbols = 'unicode'
"let g:Powerline_symbols = 'fancy'

"" over.vim
nnoremap <silent> <Leader>o :OverCommandLine<CR>%s//g<Left><Left>
nnoremap <silent> mn :OverCommandLine<CR>%s/<C-r><C-w>//g<Left><Left>
nnoremap <silent> <Leader>om y:OverCommandLine<CR>%s!<C-r>=substitute(@0, '!', '\\!', 'g')<CR>!!gI<Left><Left><Left>

" unite
vnoremap /g y:Unite grep::-iHRn:<C-R>=escape(@", '\\.*$^[]')<CR><CR>

" html
vmap <silent> sx :Str2HtmlEntity<cr>
vmap <silent> sr :Entity2HtmlString<cr>

" airsave.vim
nmap <Leader>ass  <Plug>(AutoWriteStart)
nmap <Leader>ast <Plug>(AutoWriteStop)
let g:air_auto_write = 0
let g:air_auto_write_nosilent = 0

" vim-multiple-cursors
xnoremap <C-n> :<C-u>call multiple_cursors#new('n')<CR>
nnoremap <C-n> :<C-u>call multiple_cursors#new('n')<CR>
let g:multi_cursor_start_key='<F6>'
let g:multi_cursor_use_default_mapping=1
let g:multi_cursor_next_key='<C-n>'
let g:multi_cursor_prev_key='<C-p>'
let g:multi_cursor_skip_key='<C-x>'
let g:multi_cursor_quit_key='<Esc>'

" yankround-submode
" NeoBundle 't9md/yankround.vim'
" NeoBundle 'kana/vim-submode'

" anzu
"nmap n <Plug>(anzu-n-with-echo)
"nmap N <Plug>(anzu-N-with-echo)
"nmap * <Plug>(anzu-star-with-echo)
"nmap # <Plug>(anzu-sharp-with-echo)
"nmap <Esc><Esc> <Plug>(anzu-clear-search-status)
"set statusline=%{anzu#search_status()}

" taglist
if neobundle#tap('taglist.vim')
    if has('mac')
        let Tlist_Ctags_Cmd = "/usr/local/bin/ctags"
    elseif has('win32')
        let Tlist_Ctags_Cmd = "c:/usr/local/bin/ctags.exe"
    endif

    set tags=tags
    let Tlist_Exit_OnlyWindow = 1
    let Tlist_Use_Right_Window = 1
    let Tlist_Enable_Fold_Column = 0
    let Tlist_Auto_Open = 1
    let Tlist_Auto_Update = 1
    let Tlist_WinWidth = 30
    nm <F8> :CMiniBufExplorer<CR>:TrinityToggleTagList<CR>:TMiniBufExplorer<CR>
    nm <Leader>tl :CMiniBufExplorer<CR>:TrinityToggleTagList<CR>:TMiniBufExplorer<CR>
    nm <silent> mt :<C-u>TlistToggle<CR>
endif

" deris/columnjump {{{
if neobundle#tap('columnjump')
  nmap <C-k> <C-u>  
  "nmap <C-j> <C-d>  
  nmap <C-k> <Plug>(columnjump-backward)
  "nmap <C-j> <Plug>(columnjump-forward)
endif
" }}}

" deris/vim-cmdline-switch {{{
"if neobundle#tap('vim-cmdline-switch')
"  cmap <C-j>  <Plug>(cmdline-switch)
"endif
" }}}

"" cohama/lexima {{{
"let g:lexima_no_default_rules = 1
"let g:lexima_no_map_to_escape = 1
"inoremap <silent> <Esc> <C-r>=neocomplete#close_popup()<CR><C-r>=lexima#insmode#escape()<CR><C-r>=FixedInsertLeave()<CR>
"if neobundle#tap('lexima.vim')
"  function neobundle#hooks.on_source(_)
"    call lexima#set_default_rules()
"
"    call lexima#insmode#map_hook('before', '<CR>', "\<C-r>=neocomplete#close_popup()\<CR>")
"
"    call lexima#add_rule({'at': '^```\(\S*\)\%#```', 'char': '<CR>', 'input': '<C-y><CR><CR><Esc>kS', 'filetype': ['markdown']})
"    call lexima#add_rule({'at': '^\k\+\s*::\s*.*\%#', 'char': '<CR>', 'input': '<Esc>^"qyt<Space>o<C-r>q<Space>', 'filetype': ['haskell']})
"
"    call lexima#add_rule({'at': '^\%#', 'char': ':', 'input': '<BS>:Unite history/command command<CR>', 'mode': ':'})
"
"    call lexima#add_rule({'at': 'Unite \%#', 'char': 'I', 'input': '<C-u>UniteWithInput<Space>', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite \%#', 'char': 'C', 'input': '<C-u>UniteWithCursorWord<Space>', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite \%#', 'char': 'B', 'input': '<C-u>UniteWithBufferDir<Space>', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.* \%#', 'char': ':', 'input': '<BS>:', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.* \%#', 'char': 'F', 'input': 'file ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.*file \%#', 'char': 'R', 'input': '<BS>_rec ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.*file \%#', 'char': 'M', 'input': '<BS>_mru ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.*file_rec \%#', 'char': 'A', 'input': '<BS>/async ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.*file_mru \%#', 'char': 'L', 'input': '<BS>:long ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.* \%#', 'char': 'D', 'input': 'directory ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.\+ \%#', 'char': 'B', 'input': 'bookmark ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.* \%#', 'char': 'S', 'input': 'source ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.* \%#', 'char': 'M', 'input': 'mapping ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.* \%#', 'char': 'O', 'input': 'out', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.*out\%#', 'char': 'L', 'input': 'line ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.*out\%#', 'char': 'P', 'input': 'put:', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.* \%#', 'char': 'G', 'input': 'grep ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.* \%#', 'char': 'J', 'input': 'junkfile junkfile/new ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.* \%#', 'char': 'N', 'input': 'neobundle ', 'mode': ':'})
"    let log = '<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>-log -no-start-insert <Right><Right><Right><Right><Right><Right><Right><Right><Right><Right>'
"    call lexima#add_rule({'at': 'Unite.*neobundle \%#', 'char': 'I', 'input': log . '<BS>/install ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.*neobundle \%#', 'char': 'U', 'input': log . '<BS>/update ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Unite.*neobundle/update \%#', 'char': 'U', 'input': '<BS>:! ', 'mode': ':'})
"
"    call lexima#add_rule({'at': 'RenameMe\%#', 'char': '<Space>', 'input': '<Space><C-r>%', 'mode': ':'})
"    call lexima#add_rule({'at': 'Gcommit --amend \%#', 'char': 'c', 'input': '-C HEAD', 'mode': ':'})
"    call lexima#add_rule({'at': 'Gcommit --amend \%#', 'char': 'C', 'input': '-C HEAD', 'mode': ':'})
"    call lexima#add_rule({'at': 'Git ca\%#', 'char': 'm', 'input': '<C-u>Gcommit --amend ', 'mode': ':'})
"    call lexima#add_rule({'at': 'Ocam\%#', 'char': 'l', 'input': '<BS><BS><BS>Caml', 'mode': 'i:/?'})
"    call lexima#add_rule({'at': 'SudoWrite\%#', 'char': '<Space>', 'input': '<Space><C-r>%', 'mode': ':'})
"  endfunction
"endif
"" }}}

" tommcdo/vim-exchange
"let g:exchange_no_mappings = 1
"nmap <silent> cx <Plug>(Exchange)
"nmap <silent> cxx <Plug>(ExchangeLine)

" t9md/vim-choosewin
nmap - <Plug>(choosewin)bq
nmap + <Plug>(choosewin)

" t9md/vim-textmanip
"xnap <C-S-DOWN> <Plug>(textmanip-duplicate-down)
"nmap <C-S-DOWN> <Plug>(textmanip-duplicate-down)
"xmap <M-S-DOWN> <Plug>(textmanip-move-down)
"xmap <M-S-UP> <Plug>(textmanip-move-up)
"xmap <M-S-LEFT> <Plug>(textmanip-move-left)
"xmap <M-S-RIGHT> <Plug>(textmanip-move-right)
nmap <F10> <Plug>(textmanip-toggle-mode)
xmap <F10> <Plug>(textmanip-toggle-mode)

" marks {{{
set foldmethod=marker
let g:showmarks_marks_notime = 1
let g:unite_source_mark_marks = 'ABCDEFGHIJKLNMOPQRSTUVWXYZ'
let g:showmarks_enable       = 0
if !exists('g:markrement_char')
    let g:markrement_char = [
    \     'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
    \     'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    \     'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    \     'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
    \ ]
    
endif

function! s:AutoMarkrement()
    if !exists('b:markrement_pos')
        let b:markrement_pos = 0
    else
        let b:markrement_pos = (b:markrement_pos + 1) % len(g:markrement_char)
    endif
    execute 'mark' g:markrement_char[b:markrement_pos]
    echo 'marked' g:markrement_char[b:markrement_pos]
endfunction

augroup show-marks-sync
        autocmd! 
        autocmd BufReadPost * sil! ShowMarksOnce
augroup END

nnoremap [Mark] <Nop>
nmap <leader>m [Mark]
nnoremap <silent> [Mark]m :Unite mark<CR>
nnoremap [Mark] :<C-u>call <SID>AutoMarkrement()<CR><CR>:ShowMarksOnce<CR>
com! -bar MarksDelete sil :delm! | :delm 0-9A-Z | :wv! | :ShowMarksOnce
nn <silent>[Mark]d :MarksDelete<CR>
" }}}

" gitdiff
let g:gitgutter_avoid_cmd_prompt_on_windows = 0
let g:gitgutter_system_function       = 'vimproc#system'
let g:gitgutter_system_error_function = 'vimproc#get_last_status'
let g:gitgutter_shellescape_function  = 'vimproc#shellescape'

" vim-easymotion
"nmap dj <plug>(lazy-deletelines)
nmap my ymw
nmap md dmw
nmap dj dmj
nmap yj ymj
nmap mv vmw
nmap vj vmj


" caw.vim {{{
" デフォルトマッピングを OFF
let g:caw_no_default_keymappings = 1

" キーマッピング {{{
" 行コメント
nmap <Leader>cc <Plug>(caw:i:toggle)
" 行末尾コメント
nmap <Leader>ca <Plug>(caw:a:toggle)
" ブロックコメント
nmap <Leader>cb <Plug>(caw:wrap:toggle)
" 改行後コメント
nmap <Leader>co <Plug>(caw:jump:comment-next)
nmap <Leader>cO <Plug>(caw:jump:comment-prev)
" caw 用オペレータ
let s:bundle = neobundle#get("caw.vim")
function! s:bundle.hooks.on_source(bundle)
    function! s:op_caw_commentout(motion_wise)
        if a:motion_wise ==# 'char'
            execute 'normal' "`[v`]\<Plug>(caw:wrap:toggle)"
        else
            execute "normal" "`[V`]\<Plug>(caw:i:toggle)"
        endif
    endfunction
    call operator#user#define('caw', s:SID.'op_caw_commentout')
endfunction
unlet s:bundle
map <Leader>c <Plug>(operator-caw)
"}}}

"}}}

" textobj-anyblock {{{
let g:textobj#anyblock#blocks = [ '(', '{', '[', '"', "'", '<', 'f`']
AutocmdFT help,markdown let b:textobj_anyblock_local_blocks = ['f*', 'f|']
"}}}

" vim-operator {{{
" operator-replace
map <Leader>r <Plug>(operator-replace)
" v_p を置き換える
vmap p <Plug>(operator-replace)
" operator-blank-killer
map <silent><Leader>k <Plug>(operator-trailingspace-killer)
" operator-filled-with-blank
map <silent><Leader>b <Plug>(operator-filled-with-blank)
" vim-operator-evalruby
if executable($HOME.'/.rbenv/shims/ruby')
    let g:operator_evalruby_command = $HOME . '/.rbenv/shims/ruby'
endif
map <silent><Leader>x <Plug>(operator-evalruby)
" vim-clang-format
let g:clang_format#style_options = {
            \ 'AccessModifierOffset' : -4,
            \ 'AllowShortIfStatementsOnASingleLine' : 'true',
            \ 'AlwaysBreakTemplateDeclarations' : 'true',
            \ 'Standard' : 'C++11',
            \ 'BreakBeforeBraces' : 'Stroustrup',
            \ }
AutocmdFT c,cpp map <buffer><Leader>x <Plug>(operator-clang-format)
" vim-operator-surround {{{
let g:operator#surround#blocks =
            \ {
            \   '-' : [
            \       { 'block' : ['(', ')'], 'motionwise' : ['char', 'line', 'block'], 'keys' : ['p'] },
            \       { 'block' : ['[', ']'], 'motionwise' : ['char', 'line', 'block'], 'keys' : ['c'] },
            \       { 'block' : ['{', '}'], 'motionwise' : ['char', 'line', 'block'], 'keys' : ['b'] },
            \       { 'block' : ['<', '>'], 'motionwise' : ['char', 'line', 'block'], 'keys' : ['a'] },
            \       { 'block' : ['"', '"'], 'motionwise' : ['char', 'line', 'block'], 'keys' : ['q'] },
            \       { 'block' : ["'", "'"], 'motionwise' : ['char', 'line', 'block'], 'keys' : ["s"] },
            \   ]
            \ }
map <silent>gy <Plug>(operator-surround-append)
map <silent>gd <Plug>(operator-surround-delete)
map <silent>gc <Plug>(operator-surround-replace)
nmap <silent>gdd <Plug>(operator-surround-delete)<Plug>(textobj-anyblock-a)
nmap <silent>gcc <Plug>(operator-surround-replace)<Plug>(textobj-anyblock-a)
nmap <silent>gdb <Plug>(operator-surround-delete)<Plug>(textobj-between-a)
nmap <silent>gcb <Plug>(operator-surround-replace)<Plug>(textobj-between-a)
"}}}

" vim-operator-insert
map <silent><Leader>i <Plug>(operator-insert-i)
map <silent><Leader>a <Plug>(operator-insert-a)
"}}}

nmap <Up> <C-u><C-u>
nmap <Down> <C-d><C-d>

"{
"  "to-do" : {
"    "vim" : [ "c" ],
"    "plugin" : [ "vim-operator-surround" ],
"  }
"}

"""}}}
set clipboard=unnamedplus
set clipboard+=unnamed,autoselect

source ~/dotfiles/.vimrc.seclet
set wrap

aug textwid
    au!
    autocmd FileType text setlocal textwidth=0
aug END 

inoremap <silent> <C-j> <ESC>
vnoremap <C-j> <ESC>

" vim: expandtab softtabstop=4 shiftwidth=4 foldmethod=marker
